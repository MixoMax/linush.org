Directory structure:
└── set-game/
    ├── README.md
    ├── balatro_set_cards.py
    ├── balatro_set_classes.py
    ├── balatro_set_core.py
    ├── create_tmp_images.py
    ├── LICENSE
    ├── plot_binom.py
    ├── requirements.txt
    ├── server.py
    ├── docs/
    │   ├── attributes.md
    │   ├── balatro-gamemode.md
    │   ├── balatro-scoring.md
    │   ├── balatro-todo.md
    │   └── summary.md
    └── static/
        ├── app.js
        ├── balatro-style.css
        ├── balatro.html
        ├── balatro.js
        ├── challenge.html
        ├── challenge.js
        ├── index.html
        ├── infinite.html
        ├── infinite.js
        ├── style.css
        ├── timed.html
        └── timed.js

================================================
FILE: README.md
================================================
# Set

This is a digital adaptation of the card game "Set". The game consists of a deck of 81 unique cards, each with four features: color, shape, number, and shading. The goal is to find sets of three cards where each feature is either all the same or all different.  

## Game modes:
- Time challenge: Find as many sets as possible within a given time limit.
- Infinite mode: Play without a time limit, focusing on finding sets at your own pace.
- Challenge mode: Find all sets in a given layout.

## How to play:
1. Start the game and select a mode.
2. Cards will be displayed on the screen.
3. Click on three cards that form a set.
4. If the selected cards form a valid set, they will be removed from the board, and new cards will be added.
5. If the selected cards do not form a set, they will remain on the board.


## Features:
- Leaderboard
- seeded runs
- auto-detection of sets: re-deal 12 cards if the 12 cards on the board do not contain a set
  

## TODO:
1) [x] Change the /api/v1/is_set endpoint to return why the given cards are not a set and display that information in the UI
2) [x] Nerf the "Hint" button to not show the full 3 cards that form a set, but rather indicate any one of the three cards to not immediately show the full set
3) [x] Fix the layout for when there are 15 cards on the board (right now: 3 rows of 4 cards and 1 row of 3 cards; should be 5 rows of 3 cards)
4) [x] Add a better "Start game" Menu. The one right now has a checkbox for "Infinite mode" and a checkbox for "Challenge mode", implying both can be selected at the same time, which is not the case. There should be a Seed field and three seperate buttons labeled "Time Challenge", "Infinite Mode", and "Challenge Mode" to select the game mode.
5) [ ] encode the game state (game mode, seed, excluded cards and cards on the board) in the URL (goes with 6)
6) [ ] Add a "Back" button to the game screen to return to the main menu (goes with 5)



================================================
FILE: balatro_set_cards.py
================================================
import random

from balatro_set_classes import Joker, JokerAbility, JokerTrigger, JokerVariant
from balatro_set_classes import ConsumableCard, ConsumableAbility, ConsumableTrigger
from balatro_set_classes import GameState, GameContext

JOKER_RARITY_PRICES = {"Common": 4, "Uncommon": 6, "Rare": 8, "Legendary": 10}
JOKER_VARIANT_PRICES_MULT = {JokerVariant.BASIC: 1, JokerVariant.FOIL: 1.15, JokerVariant.HOLOGRAPHIC: 1.3, JokerVariant.POLYCHROME: 1.45, JokerVariant.NEGATIVE: 1.6}

def add_random_tarot(game_state: 'GameState', number: int = 1):
    """Adds a random tarot card to the game."""
    for _ in range(number):
        if len(game_state.consumables) < game_state.consumable_slots:
            random_idx = random.randint(0, len(TAROT_DATABASE) - 1)
            card = TAROT_DATABASE.values()[random_idx].copy()
            game_state.consumables.append(card)

def t_death_ability(c: ConsumableCard, ctx: GameContext):
    """Turns 2 random other cards into a copy of 1 selected card."""
    if len(ctx.game.selected_card_indices) == 1:
        selected_card = ctx.game.deck[ctx.game.selected_card_indices[0]]
        for _ in range(2):
            if len(ctx.game.deck) < ctx.game.board_size:
                random_idx = random.randint(0, len(ctx.game.deck) - 1)
                if random_idx not in ctx.game.selected_card_indices:
                    ctx.game.deck[random_idx] = selected_card.copy()
            else:
                break

def t_wheel_ability(c: ConsumableCard, ctx: GameContext):
    if ctx.game.jokers:
        random_joker = random.choice(ctx.game.jokers)
        if random_joker.variant == JokerVariant.BASIC and random.random() < 0.25:
            new_variant = random.choice(list(JOKER_VARIANT_PRICES_MULT.keys()))
            random_joker.variant = new_variant
            random_joker.price = int(random_joker.price * JOKER_VARIANT_PRICES_MULT[new_variant])

JOKER_DATABASE = {
    # default joker
    "J_MULT": Joker(
        id="J_MULT",
        name="Joker",
        description="+4 Mult",
        rarity="Common",
        abilities=[
            JokerAbility(trigger=JokerTrigger.ON_SCORE_CALCULATION, ability=lambda j, ctx: setattr(ctx.scoring, 'additive_mult', ctx.scoring.additive_mult + 4))
        ]
    ),

    # set of +3 mult per color jokers
    "J_GREEDY": Joker(
        id="J_GREEDY",
        name="Greedy Joker",
        description="Played green cards give +3 Mult",
        rarity="Common",
        abilities=[
            JokerAbility(trigger=JokerTrigger.ON_SCORE_CARD, ability=lambda j, ctx: (
                setattr(ctx.scoring, 'additive_mult', ctx.scoring.additive_mult + 3) if ctx.scoring.current_scoring_card.attributes[0] == 2 else None
            ))
        ]
    ),
    "J_LUSTY": Joker(
        id="J_LUSTY",
        name="Lusty Joker",
        description="Played red cards give +3 Mult",
        rarity="Common",
        abilities=[
            JokerAbility(trigger=JokerTrigger.ON_SCORE_CARD, ability=lambda j, ctx: (
                setattr(ctx.scoring, 'additive_mult', ctx.scoring.additive_mult + 3) if ctx.scoring.current_scoring_card.attributes[0] == 0 else None
            ))
        ]
    ),
    "J_Wrathful": Joker(
        id="J_WRATHFUL",
        name="Wrathful Joker",
        description="Played magenta cards give +3 Mult",
        rarity="Common",
        abilities=[
            JokerAbility(trigger=JokerTrigger.ON_SCORE_CARD, ability=lambda j, ctx: (
                setattr(ctx.scoring, 'additive_mult', ctx.scoring.additive_mult + 3) if ctx.scoring.current_scoring_card.attributes[0] == 1 else None
            ))
        ]
    ),

    # +mult and + chips for played features jokers
    "J_JOLLY": Joker(
        id="J_JOLLY",
        name="Jolly Joker",
        description="+8 Mult if played set is (3U, 1L)",
        rarity="Common",
        abilities=[
            JokerAbility(trigger=JokerTrigger.ON_SCORE_CALCULATION, ability=lambda j, ctx: (
                setattr(ctx.scoring, 'additive_mult', ctx.scoring.additive_mult + 8) if ctx.game.played_set_types and ctx.game.played_set_types[-1] == "3_uniform_1_ladder" else None
            ))
        ]
    ),
    "J_ZANNY": Joker(
        id="J_ZANNY",
        name="Zanny Joker",
        description="+12 Mult if played set is (2U, 2L)",
        rarity="Common",
        abilities=[
            JokerAbility(trigger=JokerTrigger.ON_SCORE_CALCULATION, ability=lambda j, ctx: (
                setattr(ctx.scoring, 'additive_mult', ctx.scoring.additive_mult + 12) if ctx.game.played_set_types and ctx.game.played_set_types[-1] == "2_uniform_2_ladder" else None
            ))
        ]
    ),
    "J_MAD": Joker(
        id="J_MAD",
        name="Mad Joker",
        description="+16 Mult if played set is (1U, 3L)",
        rarity="Common",
        abilities=[
            JokerAbility(trigger=JokerTrigger.ON_SCORE_CALCULATION, ability=lambda j, ctx: (
                setattr(ctx.scoring, 'additive_mult', ctx.scoring.additive_mult + 16) if ctx.game.played_set_types and ctx.game.played_set_types[-1] == "1_uniform_3_ladder" else None
            ))
        ]
    ),
    "J_CRAZY": Joker(
        id="J_CRAZY",
        name="Crazy Joker",
        description="+20 Mult if played set is (0U, 4L)",
        rarity="Common",
        abilities=[
            JokerAbility(trigger=JokerTrigger.ON_SCORE_CALCULATION, ability=lambda j, ctx: (
                setattr(ctx.scoring, 'additive_mult', ctx.scoring.additive_mult + 20) if ctx.game.played_set_types and ctx.game.played_set_types[-1] == "0_uniform_4_ladder" else None
            ))
        ]
    ),
    "J_SLY": Joker(
        id="J_SLY",
        name="Sly Joker",
        description="+50 Chips if played set is (3U, 1L)",
        rarity="Common",
        abilities=[
            JokerAbility(trigger=JokerTrigger.ON_SCORE_CALCULATION, ability=lambda j, ctx: (
                setattr(ctx.scoring, 'flat_chips', ctx.scoring.flat_chips + 50) if ctx.game.played_set_types and ctx.game.played_set_types[-1] == "3_uniform_1_ladder" else None
            ))
        ]
    ),
    "J_WILY": Joker(
        id="J_WILY",
        name="Wily Joker",
        description="+100 Chips if played set is (2U, 2L)",
        rarity="Common",
        abilities=[
            JokerAbility(trigger=JokerTrigger.ON_SCORE_CALCULATION, ability=lambda j, ctx: (
                setattr(ctx.scoring, 'flat_chips', ctx.scoring.flat_chips + 100) if ctx.game.played_set_types and ctx.game.played_set_types[-1] == "2_uniform_2_ladder" else None
            ))
        ]
    ),
    "J_CLEVER": Joker(
        id="J_CLEVER",
        name="Clever Joker",
        description="+150 Chips if played set is (1U, 3L)",
        rarity="Common",
        abilities=[
            JokerAbility(trigger=JokerTrigger.ON_SCORE_CALCULATION, ability=lambda j, ctx: (
                setattr(ctx.scoring, 'flat_chips', ctx.scoring.flat_chips + 150) if ctx.game.played_set_types and ctx.game.played_set_types[-1] == "1_uniform_3_ladder" else None
            ))
        ]
    ),

    "J_STENCIL": Joker(
        id="J_STENCIL",
        name="Joker Stencil",
        description="x1 Mult for each empty Joker slot",
        rarity="Uncommon",
        display_badge="x{empty_slots} M",
        calculate_display_badge=lambda j, ctx: f"x{ctx.game.joker_slots - len(ctx.game.jokers)} M",
        abilities=[
            JokerAbility(trigger=JokerTrigger.ON_SCORE_CALCULATION, ability=lambda j, ctx: (
                setattr(ctx.scoring, 'multiplicative_mult', ctx.scoring.multiplicative_mult * (ctx.game.joker_slots - len(ctx.game.jokers)))
            ))
        ]
    ),

    "J_BANNER": Joker(
        id="J_BANNER",
        name="Banner",
        description="+30 Chips for each remaining discard",
        rarity="Common",
        display_badge="+{remaining_discards} C",
        calculate_display_badge=lambda j, ctx: f"+{ctx.game.discards_remaining * 30} C",
        abilities=[
            JokerAbility(trigger=JokerTrigger.ON_SCORE_CALCULATION, ability=lambda j, ctx: (
                setattr(ctx.scoring, 'flat_chips', ctx.scoring.flat_chips + ctx.game.discards_remaining * 30)
            ))
        ]
    ),

    "J_MYSTIC_SUMMIT": Joker(
        id="J_MYSTIC_SUMMIT",
        name="Mystic Summit",
        description="+15 Mult when 0 discards remaining",
        rarity="Common",
        abilities=[
            JokerAbility(trigger=JokerTrigger.ON_SCORE_CALCULATION, ability=lambda j, ctx: (
                setattr(ctx.scoring, 'multiplicative_mult', ctx.scoring.multiplicative_mult + 15) if ctx.game.discards_remaining == 0 else None
            ))
        ]
    ),

    "J_LOYALTY_CARD": Joker(
        id="J_LOYALTY_CARD",
        name="Loyalty Card",
        description="x4 Mult every 6 hands played",
        rarity="Uncommon",
        display_badge="{n_hands} remaining",
        custom_data={"n_hands": 6},
        abilities=[
            JokerAbility(trigger=JokerTrigger.ON_SCORE_CALCULATION, ability=lambda j, ctx: (
                setattr(ctx.scoring, 'multiplicative_mult', ctx.scoring.multiplicative_mult * 4) if ctx.game.played_set_types and len(ctx.game.played_set_types) % 6 == 0 else None
            )),
            JokerAbility(trigger=JokerTrigger.ON_SCORE_CALCULATION, ability=lambda j, ctx: (
                setattr(j.custom_data, 'n_hands', (j.custom_data['n_hands'] - 1) if j.custom_data['n_hands'] > 0 else 6)
            ))
        ],
        calculate_display_badge=lambda j, ctx: f"{j.custom_data['n_hands']} remaining"
    ),
    "J_8_BALL": Joker(
        id="J_8_BALL",
        name="8-Ball",
        description="1 in 4 to create a Tarot card when scoring",
        rarity="Common",
        abilities=[
            JokerAbility(trigger=JokerTrigger.ON_SCORE_CALCULATION, ability=lambda j, ctx: (
                add_random_tarot(ctx.game, 1) if random.random() < 0.25 else None
            ))
        ]
    ),
    "J_MISPRINT": Joker(
        id="J_MISPRINT",
        name="Misprint",
        description="+0-23 Mult",
        rarity="Common",
        abilities=[
            JokerAbility(trigger=JokerTrigger.ON_SCORE_CALCULATION, ability=lambda j, ctx: (
                setattr(ctx.scoring, 'additive_mult', ctx.scoring.additive_mult + random.randint(0, 23))
            ))
        ]
    ),
    "J_FIBONACCI": Joker(
        id="J_FIBONACCI",
        name="Fibonacci",
        description="Each played Solid Oval card gives +8 Mult",
        rarity="Common",
        abilities=[
            JokerAbility(trigger=JokerTrigger.ON_SCORE_CARD, ability=lambda j, ctx: (
                setattr(ctx.scoring, 'additive_mult', ctx.scoring.additive_mult + 8) if ctx.scoring.current_scoring_card.attributes[1] == 0 and ctx.scoring.current_scoring_card.attributes[3] == 0 else None
            ))
        ]
    ),
    "J_SCARY_FACE": Joker(
        id="J_SCARY_FACE",
        name="Scary Face",
        description="Each played card with 3 symbols gives +30 Chips",
        rarity="Common",
        abilities=[
            JokerAbility(trigger=JokerTrigger.ON_SCORE_CARD, ability=lambda j, ctx: (
                setattr(ctx.scoring, 'flat_chips', ctx.scoring.flat_chips + 30) if ctx.scoring.current_scoring_card.attributes[2] == 2 else None
            ))
        ]
    ),
    "J_ABSTRACT": Joker(
        id="J_ABSTRACT",
        name="Abstract",
        description="+3 Mult for each Joker held",
        rarity="Common",
        display_badge="+{n_jokers} M",
        abilities=[
            JokerAbility(trigger=JokerTrigger.ON_SCORE_CALCULATION, ability=lambda j, ctx: (
                setattr(ctx.scoring, 'additive_mult', ctx.scoring.additive_mult + 3 * len(ctx.game.jokers))
            ))
        ],
        calculate_display_badge=lambda j, ctx: f"+{3 * len(ctx.game.jokers)} M"
    ),
    "J_DELAYED_GRATIFICATION": Joker(
        id="J_DELAYED_GRATIFICATION",
        name="Delayed Gratification",
        description="Earn $2 per discard if no discards are used by end of round",
        rarity="Common",
        abilities=[
            JokerAbility(trigger=JokerTrigger.ON_END_OF_ROUND, ability=lambda j, ctx: (
                setattr(ctx.game, 'money', ctx.game.money + 2 * ctx.game.discards_remaining) if ctx.game.discards_remaining == ctx.game.discards_per_round else None
            ))
        ]
    ),
    "J_FACELESS": Joker(
        id="J_FACELESS",
        name="Faceless Joker",
        description="Earn $5 if 3 or more Triangle cards are discarded at the same time",
        rarity="Common",
        abilities=[
            JokerAbility(trigger=JokerTrigger.ON_DISCARD, ability=lambda j, ctx: (
                setattr(ctx.game, 'money', ctx.game.money + 5) if len([c for c in ctx.game.discard_pile if c.attributes[1] == 1]) >= 3 else None
            ))
        ]
    ),
    "J_SUPERPOSITION": Joker(
        id="J_SUPERPOSITION",
        name="Superposition",
        description="Create a Tarot card when scoring a set with a striped green card",
        rarity="Rare",
        abilities=[
            JokerAbility(trigger=JokerTrigger.ON_SCORE_CALCULATION, ability=lambda j, ctx: (
                add_random_tarot(ctx.game, 1) if any(c.attributes[0] == 2 and c.attributes[3] == 1 for c in ctx.scoring.scoring_cards) else None
            ))
        ]
    ),
    "J_VAMPIRE": Joker(
        id="J_VAMPIRE",
        name="Vampire",
        description="This joker gains x0.1 Mult per scoring enhanced card played, removes card Enhancement",
        rarity="Uncommon",
        custom_data={"eternal_x_mult": 1.0},
        abilities=[
            JokerAbility(trigger=JokerTrigger.ON_SCORE_CARD, ability=lambda j, ctx: (
                setattr(j.custom_data, 'eternal_x_mult', j.custom_data['eternal_x_mult'] + 0.1) if ctx.scoring.current_scoring_card.enhancement else None
            )),
            JokerAbility(trigger=JokerTrigger.ON_SCORE_CARD, ability=lambda j, ctx: (
                setattr(ctx.scoring.current_scoring_card, 'enhancement', None) if ctx.scoring.current_scoring_card.enhancement else None
            )),
            JokerAbility(trigger=JokerTrigger.ON_SCORE_CALCULATION, ability=lambda j, ctx: (
                setattr(ctx.scoring, 'multiplicative_mult', ctx.scoring.multiplicative_mult * j.custom_data['eternal_x_mult'])
            ))
        ],
        display_badge="{eternal_x_mult:.1f}x M",
        calculate_display_badge=lambda j, ctx: f"{j.custom_data['eternal_x_mult']:.1f}x M"
    ),
    "J_VAGABOND": Joker(
        id="J_VAGABOND",
        name="Vagabond",
        description="Create a Tarot card if hand is played with $4 or less",
        rarity="Rare",
        abilities=[
            JokerAbility(trigger=JokerTrigger.ON_SCORE_CALCULATION, ability=lambda j, ctx: (
                add_random_tarot(ctx.game, 1) if ctx.game.money <= 4 else None
            ))
        ]
    ),
    "J_MIDAS_MASK": Joker(
        id="J_MIDAS_MASK",
        name="Midas Mask",
        description="All played Solid Rectangle cards become Gold when scored",
        rarity="Uncommon",
        abilities=[
            JokerAbility(trigger=JokerTrigger.ON_SCORE_CARD, ability=lambda j, ctx: (
                setattr(ctx.scoring.current_scoring_card, 'enhancement', "gold") if ctx.scoring.current_scoring_card.attributes[1] == 2 and ctx.scoring.current_scoring_card.attributes[3] == 0 else None
            ))
        ]
    ),
    "J_DRUNKARD": Joker(
        id="J_DRUNKARD",
        name="Drunkard",
        description="+1 Discard",
        rarity="Common",
        abilities=[
            JokerAbility(trigger=JokerTrigger.ON_BUY_SELF, ability=lambda j, ctx: (
                setattr(ctx.game, 'discards_remaining', ctx.game.discards_per_round + 1)
            )),
            JokerAbility(trigger=JokerTrigger.ON_DESTROY_SELF, ability=lambda j, ctx: (
                setattr(ctx.game, 'discards_remaining', ctx.game.discards_per_round - 1 if ctx.game.discards_per_round > 0 else 0)
            ))
        ]
    ),
    "J_JUGGLER": Joker(
        id="J_JUGGLER",
        name="Juggler",
        description="+1 Play",
        rarity="Common",
        abilities=[
            JokerAbility(trigger=JokerTrigger.ON_BUY_SELF, ability=lambda j, ctx: (
                setattr(ctx.game, 'boards_remaining', ctx.game.boards_per_round + 1)
            )),
            JokerAbility(trigger=JokerTrigger.ON_DESTROY_SELF, ability=lambda j, ctx: (
                setattr(ctx.game, 'boards_remaining', ctx.game.boards_per_round - 1 if ctx.game.boards_per_round > 0 else 0)
            ))
        ]
    ),
    "J_GOLDEN": Joker(
        id="J_GOLDEN",
        name="Golden Joker",
        description="Earn $4 at end of round",
        rarity="Common",
        abilities=[
            JokerAbility(trigger=JokerTrigger.ON_END_OF_ROUND, ability=lambda j, ctx: (
                setattr(ctx.game, 'money', ctx.game.money + 4)
            ))
        ]
    ),
    "J_BASEBALL": Joker(
        id="J_BASEBALL",
        name="Baseball Card",
        description="x1.5 Mult for each Uncommon Joker held",
        rarity="Uncommon",
        custom_data={"n_uncommon_jokers": 0},
        display_badge="x{n_uncommon_jokers:.2f} M",
        calculate_display_badge=lambda j, ctx: f"x{j.custom_data['n_uncommon_jokers']:.2f} M",
        abilities=[
            JokerAbility(trigger=JokerTrigger.ON_SCORE_CALCULATION, ability=lambda j, ctx: (
                setattr(ctx.scoring, 'multiplicative_mult', ctx.scoring.multiplicative_mult * (1.5 + j.custom_data['n_uncommon_jokers']))
            )),
            JokerAbility(trigger=JokerTrigger.ON_BUY_SELF, ability=lambda j, ctx: (
                setattr(j.custom_data, 'n_uncommon_jokers', sum(1 for joker in ctx.game.jokers if joker.rarity == "Uncommon"))
            )),
            JokerAbility(trigger=JokerTrigger.ON_DISCARD, ability=lambda j, ctx: (
                setattr(j.custom_data, 'n_uncommon_jokers', sum(1 for joker in ctx.game.jokers if joker.rarity == "Uncommon"))
            )),
            JokerAbility(trigger=JokerTrigger.ON_DESTROY_SELF, ability=lambda j, ctx: (
                setattr(j.custom_data, 'n_uncommon_jokers', sum(1 for joker in ctx.game.jokers if joker.rarity == "Uncommon"))
            )),
            JokerAbility(trigger=JokerTrigger.ON_BUY_JOKER, ability=lambda j, ctx: (
                setattr(j.custom_data, 'n_uncommon_jokers', sum(1 for joker in ctx.game.jokers if joker.rarity == "Uncommon"))
            )),
            JokerAbility(trigger=JokerTrigger.ON_DESTROY_JOKER, ability=lambda j, ctx: (
                setattr(j.custom_data, 'n_uncommon_jokers', sum(1 for joker in ctx.game.jokers if joker.rarity == "Uncommon"))
            ))
        ]
    ),
    "J_BULL": Joker(
        id="J_BULL",
        name="Bull",
        description="+2 Chips for each $1 you have",
        rarity="Uncommon",
        display_badge="+{chips} C",
        calculate_display_badge=lambda j, ctx: f"+{2 * ctx.game.money} C",
        abilities=[
            JokerAbility(trigger=JokerTrigger.ON_SCORE_CALCULATION, ability=lambda j, ctx: (
                setattr(ctx.scoring, 'flat_chips', ctx.scoring.flat_chips + 2 * ctx.game.money)
            ))
        ]
    ),
    "J_POPCORN": Joker(
        id="J_POPCORN",
        name="Popcorn",
        description="+20 Mult, -4 Mult per round played",
        rarity="Common",
        custom_data={"rounds_played": 0},
        display_badge="+{mult} M",
        calculate_display_badge=lambda j, ctx: f"+{max(0, 20 - 4 * j.custom_data['rounds_played'])} M",
        abilities=[
            JokerAbility(trigger=JokerTrigger.ON_SCORE_CALCULATION, ability=lambda j, ctx: (
                setattr(ctx.scoring, 'additive_mult', ctx.scoring.additive_mult + max(0, 20 - 4 * j.custom_data['rounds_played']))
            )),
            JokerAbility(trigger=JokerTrigger.ON_END_OF_ROUND, ability=lambda j, ctx: (
                j.custom_data.update({'rounds_played': j.custom_data['rounds_played'] + 1})
            )),
        ]
    ),
    "J_ACROBAT": Joker(
        id="J_ACROBAT",
        name="Acrobat",
        description="x3 Mult on final played set of the round",
        rarity="Uncommon",
        abilities=[
            JokerAbility(trigger=JokerTrigger.ON_SCORE_CALCULATION, ability=lambda j, ctx: (
                setattr(ctx.scoring, 'multiplicative_mult', ctx.scoring.multiplicative_mult * 3) if ctx.game.boards_remaining == 0 else None
            ))
        ]
    ),
    "J_ROUGH_GEM": Joker(
        id="J_ROUGH_GEM",
        name="Rough Gem",
        description="Played Green cards earn $1",
        rarity="Uncommon",
        abilities=[
            JokerAbility(trigger=JokerTrigger.ON_SCORE_CARD, ability=lambda j, ctx: (
                setattr(ctx.game, 'money', ctx.game.money + 1) if ctx.scoring.current_scoring_card.attributes[0] == 2 else None
            ))
        ]
    ),
    "J_BLOODSTONE": Joker(
        id="J_BLOODSTONE",
        name="Bloodstone",
        description="Played Red cards have a 1 in 2 chance to give x1.5 Mult",
        rarity="Uncommon",
        abilities=[
            JokerAbility(trigger=JokerTrigger.ON_SCORE_CARD, ability=lambda j, ctx: (
                setattr(ctx.scoring, 'multiplicative_mult', ctx.scoring.multiplicative_mult * 1.5) if ctx.scoring.current_scoring_card.attributes[0] == 0 and random.random() < 0.5 else None
            ))
        ]
    ),
    "J_ONYX": Joker(
        id="J_ONYX",
        name="Onyx",
        description="Played Magenta cards give +50 Chips",
        rarity="Uncommon",
        abilities=[
            JokerAbility(trigger=JokerTrigger.ON_SCORE_CARD, ability=lambda j, ctx: (
                setattr(ctx.scoring, 'flat_chips', ctx.scoring.flat_chips + 50) if ctx.scoring.current_scoring_card.attributes[0] == 1 else None
            ))
        ]
    ),
    "J_FLOWER": Joker(
        id="J_FLOWER",
        name="Flower Pot",
        description="x3 Mult if played set containsa Green, a Red, and a Magenta card",
        rarity="Uncommon",
        abilities=[
            JokerAbility(trigger=JokerTrigger.ON_SCORE_CALCULATION, ability=lambda j, ctx: (
                setattr(ctx.scoring, 'multiplicative_mult', ctx.scoring.multiplicative_mult * 3) if any(c.attributes[0] == 2 for c in ctx.scoring.scoring_cards) and
                                                       any(c.attributes[0] == 0 for c in ctx.scoring.scoring_cards) and
                                                       any(c.attributes[0] == 1 for c in ctx.scoring.scoring_cards) else None
            ))
        ]
    ),
    "J_WEE": Joker(
        id="J_WEE",
        name="Wee Joker",
        description="This Joker gains +8 Chips for each played Single Triangle card",
        custom_data={"chips": 0},
        display_badge="+{chips} C",
        calculate_display_badge=lambda j, ctx: f"+{j.custom_data['chips']} C",
        rarity="Rare",
        abilities=[
            JokerAbility(trigger=JokerTrigger.ON_SCORE_CARD, ability=lambda j, ctx: (
                j.custom_data.update({'chips': j.custom_data['chips'] + 8}) if ctx.scoring.current_scoring_card.attributes[1] == 1 and ctx.scoring.current_scoring_card.attributes[3] == 0 else None
            )),
            JokerAbility(trigger=JokerTrigger.ON_SCORE_CALCULATION, ability=lambda j, ctx: (
                setattr(ctx.scoring, 'flat_chips', ctx.scoring.flat_chips + j.custom_data['chips']) if j.custom_data['chips'] else None
            ))
        ]
    ),
}

TAROT_DATABASE = {
    "T_FOOL": ConsumableCard(
        id="T_FOOL",
        name="The Fool",
        description="Creates a copy of the last used Tarot or Planet card.",
        rarity="Common",
        abilities=[
            ConsumableAbility(trigger=ConsumableTrigger.ON_USE, ability=lambda c, ctx: (
                ctx.game.consumables.append(ctx.game.last_consumable_used.copy() if ctx.game.last_consumable_used else None)
            ))
        ]
    ),

    "T_MAGICIAN": ConsumableCard(
        id="T_MAGICIAN",
        name="The Magician",
        description="Enhances 2 selected cards to Lucky Cards.",
        tooltip="(Lucky: 1 in 5 chance for +20 Mult, 1 in 15 chance to win $20)",
        rarity="Common",
        target_count=2,
        abilities=[
            ConsumableAbility(trigger=ConsumableTrigger.ON_USE, ability=lambda c, ctx: (
                [setattr(ctx.game.deck[i], 'enhancement', 'lucky') for i in ctx.game.selected_card_indices if i < len(ctx.game.deck)]
            ))
        ]
    ),
    
    "T_HIGH_PRIESTESS": ConsumableCard(
        id="T_HIGH_PRIESTESS",
        name="The High Priestess",
        description="Does Nothing yet.",
        rarity="Common",
        abilities=[
            ConsumableAbility(trigger=ConsumableTrigger.ON_USE, ability=lambda c, ctx: (
                None  # Placeholder for future functionality
            ))
        ]
    ),
    "T_EMPRESS": ConsumableCard(
        id="T_EMPRESS",
        name="The Empress",
        description="Enhances 2 selected cards to Mult Cards.",
        tooltip="(Mult: +4 Mult)",
        rarity="Common",
        target_count=2,
        abilities=[
            ConsumableAbility(trigger=ConsumableTrigger.ON_USE, ability=lambda c, ctx: (
                [setattr(ctx.game.deck[i], 'enhancement', 'mult') for i in ctx.game.selected_card_indices if i < len(ctx.game.deck)]
            ))
        ]
    ),
    "T_EMPEROR": ConsumableCard(
        id="T_EMPEROR",
        name="The Emperor",
        description="Creates 2 random Tarot cards.",
        tooltip="(must have room)",
        rarity="Common",
        abilities=[
            ConsumableAbility(trigger=ConsumableTrigger.ON_USE, ability=lambda c, ctx: (
                add_random_tarot(ctx.game, 2) # function takes care of room check
            ))
        ]
    ),
    "T_HIEROPHANT": ConsumableCard(
        id="T_HIEROPHANT",
        name="The Hierophant",
        description="Enhances 2 selected cards to Bonus Cards.",
        tooltip="(Bonus: +30 Chips)",
        rarity="Common",
        target_count=2,
        abilities=[
            ConsumableAbility(trigger=ConsumableTrigger.ON_USE, ability=lambda c, ctx: (
                [setattr(ctx.game.deck[i], 'enhancement', 'bonus') for i in ctx.game.selected_card_indices if i < len(ctx.game.deck)]
            ))
        ]
    ),
    "T_LOVERS": ConsumableCard(
        id="T_LOVERS",
        name="The Lovers",
        description="Enhances 1 selected card into a Wild Card.",
        tooltip="(Wild: Can be used as any card)",
        rarity="Common",
        target_count=1,
        abilities=[
            ConsumableAbility(trigger=ConsumableTrigger.ON_USE, ability=lambda c, ctx: (
                [setattr(ctx.game.deck[i], 'attributes', [-1, -1, -1, -1]) for i in ctx.game.selected_card_indices if i < len(ctx.game.deck)]
            ))
        ]
    ),
    "T_CHARIOT": ConsumableCard(
        id="T_CHARIOT",
        name="The Chariot",
        description="Enhances 1 selected card into a Steel Card.",
        tooltip="(Steel: x1.5 Mult while this card stays on the board)",
        rarity="Common",
        target_count=1,
        abilities=[
            ConsumableAbility(trigger=ConsumableTrigger.ON_USE, ability=lambda c, ctx: (
                [setattr(ctx.game.deck[i], 'enhancement', 'steel') for i in ctx.game.selected_card_indices if i < len(ctx.game.deck)]
            ))
        ]
    ),
    "T_JUSTICE": ConsumableCard(
        id="T_JUSTICE",
        name="Justice",
        description="Enhances 1 selected card into a Glass Card.",
        tooltip="(x2 Mult, 1 in 4 chance to be destroyed when played)",
        rarity="Common",
        target_count=1,
        abilities=[
            ConsumableAbility(trigger=ConsumableTrigger.ON_USE, ability=lambda c, ctx: (
                [setattr(ctx.game.deck[i], 'enhancement', 'glass') for i in ctx.game.selected_card_indices if i < len(ctx.game.deck)]
            ))
        ]
    ),
    "T_HERMIT": ConsumableCard(
        id="T_HERMIT",
        name="The Hermit",
        description="Doubles Money (Max of $20)",
        tooltip="(Max $20)",
        rarity="Common",
        abilities=[
            ConsumableAbility(trigger=ConsumableTrigger.ON_USE, ability=lambda c, ctx: (
                setattr(ctx.game, 'money', ctx.game.money + min(20, max(0, ctx.game.money)))
            ))
        ]
    ),
    "T_WHEEL_OF_FORTUNE": ConsumableCard(
        id="T_WHEEL_OF_FORTUNE",
        name="Wheel of Fortune",
        description="1 in 4 chance to add Foil, Holographic, or Polychrome edition to a random joker.",
        rarity="Common",
        abilities=[
            ConsumableAbility(trigger=ConsumableTrigger.ON_USE, ability=t_wheel_ability)
        ]
    ),
    "T_STRENGTH": ConsumableCard(
        id="T_STRENGTH",
        name="Strength",
        description="Does Nothing yet.",
        rarity="Common",
        abilities=[
            ConsumableAbility(trigger=ConsumableTrigger.ON_USE, ability=lambda c, ctx: None)
        ]
    ),
    "T_HANGED": ConsumableCard(
        id="T_HANGED",
        name="The Hanged Man",
        description="Destroys 2 selected cards.",
        rarity="Common",
        target_count=2,
        abilities=[
            ConsumableAbility(trigger=ConsumableTrigger.ON_USE, ability=lambda c, ctx: (
                [ctx.game.deck.pop(i) for i in sorted(ctx.game.selected_card_indices, reverse=True) if i < len(ctx.game.deck)]
            ))
        ]
    ),
    "T_DEATH": ConsumableCard(
        id="T_DEATH",
        name="Death",
        description="Turns 2 random other cards into a copy of 1 selected card.",
        rarity="Common",
        target_count=1,
        abilities=[
            ConsumableAbility(trigger=ConsumableTrigger.ON_USE, ability=t_death_ability)
        ]
    ),
    "T_TEMPERANCE": ConsumableCard(
        id="T_TEMPERANCE",
        name="Temperance",
        description="Gives the total sell value of all current Jokers.",
        tooltip="(Max of $50)",
        rarity="Common",
        abilities=[
            ConsumableAbility(trigger=ConsumableTrigger.ON_USE, ability=lambda c, ctx: (
                setattr(ctx.game, 'money', ctx.game.money + min(50, sum(joker.price for joker in ctx.game.jokers)))
            ))
        ]
    ),
    "T_DEVIL": ConsumableCard(
        id="T_DEVIL",
        name="The Devil",
        description="Enhances 1 selected card into a Gold Card.",
        tooltip="(Gold: Earn $3 if this card is on board at end of round)",
        rarity="Common",
        target_count=1,
        abilities=[
            ConsumableAbility(trigger=ConsumableTrigger.ON_USE, ability=lambda c, ctx: (
                [setattr(ctx.game.deck[i], 'enhancement', 'gold') for i in ctx.game.selected_card_indices if i < len(ctx.game.deck)]
            ))
        ]
    ),
    "T_TOWER": ConsumableCard(
        id="T_TOWER",
        name="The Tower",
        description="Does Nothing yet.",
        rarity="Common",
        abilities=[
            ConsumableAbility(trigger=ConsumableTrigger.ON_USE, ability=lambda c, ctx: (
                None  # Placeholder for future functionality
            ))
        ]
    ),
}


================================================
FILE: balatro_set_classes.py
================================================
from typing import List, Dict, Any, Optional, Callable
from enum import Enum
from pydantic import BaseModel, Field

class JokerTrigger(Enum):
    ON_SCORE_CALCULATION = "on_score_calculation"
    ON_SCORE_CARD = "on_score_card"
    ON_END_OF_ROUND = "on_end_of_round"
    ON_DISCARD = "on_discard"

    ON_CONSUMABLE_USE = "on_consumable_use"
    ON_BUY_SELF = "on_buy_self"
    ON_DESTROY_SELF = "on_destroy_self"
    ON_BUY_JOKER = "on_buy_joker"
    ON_DESTROY_JOKER = "on_destroy_joker"

   #May not work correctly
    ON_START_ROUND = "on_start_round"


class ConsumableTrigger(Enum):
    ON_USE = "on_use"

class JokerVariant(str, Enum):
    BASIC = "basic"
    FOIL = "foil"
    HOLOGRAPHIC = "holographic"
    POLYCHROME = "polychrome"
    NEGATIVE = "negative"

class ScoreLogEntry(BaseModel):
    source_type: str # 'set', 'card', 'joker'
    source_name: str
    description: str
    chips_before: float
    mult_before: float
    chips_after: float
    mult_after: float
    trigger_phase: str = "unknown"  # 'card_scoring', 'end_scoring'

class ScoringContext(BaseModel):
    """Holds the values being calculated during scoring."""
    base_chips: int
    base_mult: float
    flat_chips: int
    additive_mult: float
    multiplicative_mult: float
    uniform_features: int
    ladder_features: int
    set_type_string: str
    score_log: List[ScoreLogEntry] = []
    current_scoring_card: Optional['Card'] = None  # The card currently being scored (for ON_SCORE_CARD triggers)
    scoring_cards: List['Card']

class ConsumableContext(BaseModel):
    """A container for passing context to consumable abilities."""
    game: 'GameState'
    message: str

class GameContext(BaseModel):
    """A container for passing game state and other context to abilities."""
    game: 'GameState'
    scoring: Optional[ScoringContext] = None
    consumable: Optional[ConsumableContext] = None
    selected_card_indices: List[int] = []

class JokerAbility(BaseModel):
    trigger: JokerTrigger
    ability: Callable[['Joker', GameContext], None]
    class Config: arbitrary_types_allowed = True

class ConsumableAbility(BaseModel):
    trigger: ConsumableTrigger
    ability: Callable[['ConsumableCard', GameContext], None]
    class Config: arbitrary_types_allowed = True

class Joker(BaseModel):
    id: str
    name: str
    description: str
    rarity: str

    variant: JokerVariant = JokerVariant.BASIC

    display_badge: Optional[str] = None
    calculate_display_badge: Callable[['Joker', GameContext], Optional[str]] = None

    custom_data: Dict[str, Any] = Field(default_factory=dict, exclude=True)

    abilities: List[JokerAbility] = Field([], exclude=True)

    def copy(self, **kwargs):
        new_abilities = [a.copy(deep=True) for a in self.abilities]
        return super().copy(update={'abilities': new_abilities}, **kwargs)

class ConsumableCard(BaseModel):
    id: str
    name: str
    description: str
    rarity: str
    tooltip: Optional[str] = None
    abilities: List[ConsumableAbility] = Field([], exclude=True)
    target_count: int = 0

class Card(BaseModel):
    attributes: List[int]
    enhancement: Optional[str] = None

class ShopSlot(BaseModel):
    item: Optional[Joker]
    price: int
    is_purchased: bool = False

class PackOpeningChoice(BaseModel):
    id: str
    name: str
    description: str

class PackOpeningState(BaseModel):
    pack_type: str  # "Celestial" or "Tarot"
    choices: List[PackOpeningChoice]
    rarity: str
    choose: int

class BoosterPack(BaseModel):
    name: str
    price: int
    is_purchased: bool = False

class ShopState(BaseModel):
    joker_slots: List[ShopSlot] = []
    booster_pack_slots: List[BoosterPack] = []

class GameState(BaseModel):
    id: str = ""
    deck: List[Card] = []
    board: List[Card] = []
    discard_pile: List[Card] = []
    played_set_types: List[str] = []
    set_type_levels: Dict[str, int] = {}
    last_consumable_used: Optional[ConsumableCard] = None
    consumables: List[ConsumableCard] = []
    consumable_slots: int = 2
    money: int = 0
    boss_blind_effect: Optional[str] = None
    ante: int = 1
    round_score: int = 0
    current_blind_index: int = 0
    boards_per_round: int = 4
    boards_remaining: int = 4
    discards_per_round: int = 3
    discards_remaining: int = 3
    board_size: int = 12
    base_board_size: int = 12
    jokers: List[Joker] = []
    joker_slots: int = 5
    shop_state: ShopState = ShopState()
    pack_opening_state: Optional[PackOpeningState] = None
    game_phase: str = "playing"
    run_won: bool = False

    def model_dump(self, **kwargs):
        """Custom model dump to exclude abilities from serialization."""
        
        update_joker_badges(self)
        
        dump = super().model_dump(**kwargs)

        # Exclude the 'abilities' field from jokers and consumables as they are not JSON serializable
        if 'jokers' in dump:
            for idx, joker in enumerate(dump['jokers']):
                joker.pop('abilities', None)
                joker.pop('calculate_display_badge', None)
                joker["custom_data"] = self.jokers[idx].custom_data  # Ensure custom data is included
        if 'consumables' in dump:
            for consumable in dump['consumables']:
                consumable.pop('abilities', None)
        if 'last_consumable_used' in dump and dump['last_consumable_used']:
            dump['last_consumable_used'].pop('abilities', None)
        if 'pack_opening_state' in dump and dump['pack_opening_state']:
            # No un-serializable fields in PackOpeningState, but good practice
            pass
        if 'shop_state' in dump:
            for slot in dump['shop_state']['joker_slots']:
                item = slot.get('item')
                if item:
                    item.pop('abilities', None)
                    item.pop('calculate_display_badge', None)

        return dump
    
def update_joker_badges(game: GameState):
    ctx = GameContext(game=game, scoring=None)
    for joker in game.jokers:
        if joker.calculate_display_badge is not None:
            joker.display_badge = joker.calculate_display_badge(joker, ctx)


================================================
FILE: balatro_set_core.py
================================================
import random
import itertools
from typing import List, Any, Optional

from balatro_set_classes import GameState, GameContext, ScoreLogEntry
from balatro_set_classes import Joker, JokerAbility, JokerTrigger, JokerVariant
from balatro_set_classes import ConsumableCard, ConsumableTrigger, ConsumableContext, ConsumableAbility

#%% --- Game Logic ---
def get_joker_by_name(game_state: 'GameState', name: str) -> Optional['Joker']:
    """Finds a joker instance by its name."""
    for j in game_state.jokers:
        if j.name == name:
            return j
    return None

def retrieve_from_discard(game_state: 'GameState', count: int):
    """Retrieves random cards from the discard pile back to board."""
    if not game_state.discard_pile:
        return
    
    for _ in range(count):
        if len(game_state.board) >= game_state.board_size or not game_state.discard_pile:
            break
        card_to_retrieve = random.choice(game_state.discard_pile)
        game_state.discard_pile.remove(card_to_retrieve)
        game_state.board.append(card_to_retrieve)

def b_create_deck():
    return [list(p) for p in itertools.product(range(3), repeat=4)]

def b_is_set(cards: List[List[int]]):
    if len(cards) != 3: return False
    for i in range(4):
        # Wildcard attribute is -1
        features = [card[i] for card in cards]
        non_wild_features = [f for f in features if f != -1]
        
        # If 0, 1, or 2 cards are real, a set is always possible
        if len(non_wild_features) <= 2:
            continue
        
        # If all 3 cards are real, apply original logic
        if len(set(non_wild_features)) not in [1, 3]:
            return False
            
    return True

GameContext.model_rebuild()
ConsumableContext.model_rebuild()

ANTE_CONFIG = {
    1: {"scores": [300, 450, 600], "names": ["Small Blind", "Big Blind", "The Wall"], "boss_effects": [None, None, "debuff_first_joker"]},
    2: {"scores": [800, 1200, 1600], "names": ["Small Blind", "Big Blind", "The Needle"], "boss_effects": [None, None, "reduce_board_size"]},
    3: {"scores": [2000, 3000, 4000], "names": ["Small Blind", "Big Blind", "The Mark"]},
    4: {"scores": [6000, 9000, 12000], "names": ["Small Blind", "Big Blind", "Boss Blind"]},
    5: {"scores": [15000, 22000, 30000], "names": ["Small Blind", "Big Blind", "Boss Blind"]},
    6: {"scores": [40000, 60000, 80000], "names": ["Small Blind", "Big Blind", "Boss Blind"]},
    7: {"scores": [100000, 150000, 200000], "names": ["Small Blind", "Big Blind", "Boss Blind"]},
    8: {"scores": [250000, 375000, 500000], "names": ["Small Blind", "Big Blind", "Boss Blind"]},
}

PACK_RARITIES = {
    "Common": {"show": 2, "choose": 1, "weight": 70},
    "Uncommon": {"show": 4, "choose": 1, "weight": 20},
    "Rare": {"show": 4, "choose": 2, "weight": 8},
    "Legendary": {"show": 5, "choose": 2, "weight": 2},
}

def get_random_joker_by_rarity(available_jokers: list[Joker]) -> Optional[Joker]:
    """Selects a random joker based on weighted rarity."""
    if not available_jokers:
        return None

    rarity_weights = {
        "Common": 70,
        "Uncommon": 20,
        "Rare": 8,
        "Legendary": 2
    }

    jokers_by_rarity = {rarity: [] for rarity in rarity_weights.keys()}
    for joker in available_jokers:
        if joker.rarity in jokers_by_rarity:
            jokers_by_rarity[joker.rarity].append(joker)

    possible_rarities = [r for r, j_list in jokers_by_rarity.items() if j_list]
    if not possible_rarities:
        return None

    weights = [rarity_weights[r] for r in possible_rarities]
    chosen_rarity = random.choices(possible_rarities, weights=weights, k=1)[0]
    chosen_joker: Joker = random.choice(jokers_by_rarity[chosen_rarity])

    variant_weights = {
        JokerVariant.BASIC: 75,
        JokerVariant.FOIL: 10,
        JokerVariant.HOLOGRAPHIC: 7,
        JokerVariant.POLYCHROME: 5,
        JokerVariant.NEGATIVE: 3
    }

    chosen_variant = random.choices(list(variant_weights.keys()), weights=list(variant_weights.values()),k=1)[0]

    match chosen_variant:
        case JokerVariant.BASIC:
            pass
        case JokerVariant.FOIL:
            chosen_joker.variant = JokerVariant.FOIL
            chosen_joker.abilities.append(JokerAbility(trigger=JokerTrigger.ON_SCORE_CALCULATION, ability=lambda j, ctx: setattr(ctx.scoring, 'flat_chips', ctx.scoring.flat_chips + 50)))
        case JokerVariant.HOLOGRAPHIC:
            chosen_joker.variant = JokerVariant.HOLOGRAPHIC
            chosen_joker.abilities.append(JokerAbility(trigger=JokerTrigger.ON_SCORE_CALCULATION, ability=lambda j, ctx: setattr(ctx.scoring, 'additive_mult', ctx.scoring.additive_mult + 10)))
        case JokerVariant.POLYCHROME:
            chosen_joker.variant = JokerVariant.POLYCHROME
            chosen_joker.abilities.append(JokerAbility(trigger=JokerTrigger.ON_SCORE_CALCULATION, ability=lambda j, ctx: setattr(ctx.scoring, 'multiplicative_mult', ctx.scoring.multiplicative_mult * 1.5)))
        case JokerVariant.NEGATIVE:
            chosen_joker.variant = JokerVariant.NEGATIVE
            chosen_joker.abilities.append(JokerAbility(trigger=JokerTrigger.ON_BUY_SELF, ability= lambda j, ctx: setattr(ctx.game, 'joker_slots', ctx.game.joker_slots + 1)))
            chosen_joker.abilities.append(JokerAbility(trigger=JokerTrigger.ON_DESTROY_SELF, ability= lambda j, ctx: setattr(ctx.game, 'joker_slots', ctx.game.joker_slots - 1)))

    return chosen_joker


def get_random_pack_rarity():
    rarities = list(PACK_RARITIES.keys())
    weights = [d['weight'] for d in PACK_RARITIES.values()]
    return random.choices(rarities, weights=weights, k=1)[0]

def get_current_blind_info(game: GameState) -> dict[str, Any]:
    ante_info = ANTE_CONFIG.get(game.ante)
    if not ante_info or game.current_blind_index >= len(ante_info["scores"]):
        return {"name": "Unknown", "score_required": 999999}
    return {"name": ante_info["names"][game.current_blind_index], "score_required": ante_info["scores"][game.current_blind_index]}

def trigger_joker_abilities(game_ctx: GameContext, trigger: JokerTrigger):
    active_jokers = game_ctx.game.jokers
    if game_ctx.game.boss_blind_effect == "debuff_first_joker" and trigger == JokerTrigger.ON_SCORE_CALCULATION:
        active_jokers = game_ctx.game.jokers[1:]

    scoring_ctx = game_ctx.scoring if game_ctx.scoring else None

    abilities_to_run = [(joker, ability) for joker in active_jokers for ability in joker.abilities if ability.trigger == trigger]
    
    print(f"Triggering {len(abilities_to_run)} joker abilities for trigger: {trigger.name}")
    
    # Determine trigger phase for logging
    trigger_phase = "end_scoring" if trigger == JokerTrigger.ON_SCORE_CALCULATION else "card_scoring"
    
    for joker, ability_def in abilities_to_run:
        if scoring_ctx:
            chips_before = scoring_ctx.base_chips + scoring_ctx.flat_chips
            mult_before = (scoring_ctx.base_mult + scoring_ctx.additive_mult) * scoring_ctx.multiplicative_mult
            flat_chips_before = scoring_ctx.flat_chips
            additive_mult_before = scoring_ctx.additive_mult
            multiplicative_mult_before = scoring_ctx.multiplicative_mult
        
        print(f"Running ability {ability_def.ability.__name__} for joker {joker.name} with trigger {trigger.name}")
        ability_def.ability(joker, game_ctx)

        if scoring_ctx:
            chips_after = scoring_ctx.base_chips + scoring_ctx.flat_chips
            mult_after = (scoring_ctx.base_mult + scoring_ctx.additive_mult) * scoring_ctx.multiplicative_mult
            
            # Check what specific changes were made
            chips_change = scoring_ctx.flat_chips - flat_chips_before
            additive_mult_change = scoring_ctx.additive_mult - additive_mult_before
            multiplicative_mult_change = scoring_ctx.multiplicative_mult / multiplicative_mult_before
            print(f"Joker {joker.name} ability {ability_def.ability.__name__} changed chips from {chips_before} to {chips_after}, mult from {mult_before} to {mult_after}")

            if chips_change != 0 or additive_mult_change != 0 or abs(multiplicative_mult_change - 1) > 0.001:
                description = ""
                
                # Priority order: chips -> additive mult -> multiplicative mult
                if chips_change > 0: 
                    description = f"+{int(chips_change)} Chips"
                elif chips_change < 0:
                    description = f"{int(chips_change)} Chips"
                elif additive_mult_change > 0:
                    if isinstance(additive_mult_change, int) or additive_mult_change.is_integer():
                         description = f"+{int(additive_mult_change)} Mult"
                    else:
                         description = f"+{additive_mult_change:.1f} Mult"
                elif additive_mult_change < 0:
                    if isinstance(additive_mult_change, int) or additive_mult_change.is_integer():
                        description = f"{int(additive_mult_change)} Mult"
                    else:
                        description = f"{additive_mult_change:.1f} Mult"
                elif abs(multiplicative_mult_change - 1) > 0.001:
                    if multiplicative_mult_change.is_integer():
                        description = f"x{int(multiplicative_mult_change)} Mult"
                    else:
                        description = f"x{multiplicative_mult_change:.1f} Mult"

                if description:  # Only log if there's an actual change
                    scoring_ctx.score_log.append(ScoreLogEntry(
                        source_type='joker',
                        source_name=joker.name,
                        description=description.strip(),
                        chips_before=chips_before,
                        mult_before=mult_before,
                        chips_after=chips_after,
                        mult_after=mult_after,
                        trigger_phase=trigger_phase
                    ))

def trigger_consumable_abilities(game: GameState, consumable: ConsumableCard, trigger: ConsumableTrigger, game_ctx: GameContext):
    abilities_to_run = [ability for ability in consumable.abilities if ability.trigger == trigger]
    for ability_def in abilities_to_run:
        ability_def.ability(consumable, game_ctx)


================================================
FILE: create_tmp_images.py
================================================
from PIL import Image, ImageDraw, ImageFont
import re
import os
from balatro_set_core import JOKER_DATABASE, TAROT_DATABASE

WIDTH = 400
HEIGHT = 600
TITLE_FONT_SIZE = 52
DESCRIPTION_FONT_SIZE = 36


def wrap_text(text, font, max_width, draw):
    """Wraps text to fit within a maximum width."""
    if not text:
        return ""
    
    lines = []
    # Preserve existing newlines
    for paragraph in text.split('\n'):
        words = paragraph.split(' ')
        if not words:
            lines.append('')
            continue

        current_line = words[0]
        for word in words[1:]:
            # Check width of the current line with the new word
            if draw.textbbox((0, 0), current_line + " " + word, font=font)[2] <= max_width:
                current_line += " " + word
            else:
                lines.append(current_line)
                current_line = word
        lines.append(current_line)
    
    return "\n".join(lines)


def create_card_image(card_id, card_name, description, output_dir):
    width, height = WIDTH, HEIGHT
    text_box_height = int(height * 0.2)

    if not os.path.exists(output_dir):
        os.makedirs(output_dir)

    try:
        title_font = ImageFont.truetype("arial.ttf", TITLE_FONT_SIZE)
        description_font = ImageFont.truetype("arial.ttf", DESCRIPTION_FONT_SIZE)
    except IOError:
        title_font = ImageFont.load_default()
        description_font = ImageFont.load_default()

    image = Image.new("RGB", (width, height), "white")
    draw = ImageDraw.Draw(image)

    # Draw text box background
    draw.rectangle([0, 0, width, text_box_height], fill="lightgrey")

    # Wrap and draw title
    wrapped_title = wrap_text(card_name, title_font, width - 20, draw)
    title_bbox = draw.textbbox((0, 0), wrapped_title, font=title_font)
    title_width = title_bbox[2] - title_bbox[0]
    title_height = title_bbox[3] - title_bbox[1]
    title_x = (width - title_width) / 2
    title_y = (text_box_height - title_height) / 2
    draw.text((title_x, title_y), wrapped_title, fill="black", font=title_font, align="center")

    # Wrap and draw description
    wrapped_description = wrap_text(description, description_font, width - 20, draw)
    desc_bbox = draw.textbbox((0, 0), wrapped_description, font=description_font)
    desc_width = desc_bbox[2] - desc_bbox[0]
    desc_height = desc_bbox[3] - desc_bbox[1]
    desc_x = (width - desc_width) / 2
    desc_y = text_box_height + (height - text_box_height - desc_height) / 2
    draw.text((desc_x, desc_y), wrapped_description, fill="black", font=description_font, align="center")

    # Save image
    output_filename = os.path.join(output_dir, f"{card_id}.webp")
    image.save(output_filename, "WEBP")
    print(f"Created {output_filename}")

if __name__ == "__main__":
    script_dir = os.path.dirname(os.path.abspath(__file__))
    img_dir = os.path.join(script_dir, "static", "images")
    for card_id, card_data in JOKER_DATABASE.items():
        create_card_image(card_id, card_data.name, card_data.description, img_dir)
    for card_id, card_data in TAROT_DATABASE.items():
        create_card_image(card_id, card_data.name, card_data.description, img_dir)




================================================
FILE: LICENSE
================================================
MIT License

Copyright (c) 2025 Linus Horn

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.



================================================
FILE: plot_binom.py
================================================
import requests
import matplotlib.pyplot as plt
from tqdm import tqdm
from concurrent.futures import ThreadPoolExecutor, as_completed
import argparse

session = requests.Session()

def fetch_one(n_cards, server_url):
    global session
    cards_response = session.post(f"{server_url}/deal_cards", json={"n_cards": n_cards})
    cards_response.raise_for_status()
    cards_json = cards_response.json()["cards"]

    sets_response = session.post(f"{server_url}/find_all_sets", json=cards_json)
    sets_response.raise_for_status()
    all_sets = sets_response.json()["sets"]
    
    return len(all_sets)

def calculate_frequency(n_cards, n_samples, max_workers, server_url):
    frequency = {}
    with ThreadPoolExecutor(max_workers=max_workers) as executor:
        futures = [executor.submit(fetch_one, n_cards, server_url) for _ in range(n_samples)]
        for future in tqdm(as_completed(futures), total=n_samples):
            n_sets = future.result()
            frequency[n_sets] = frequency.get(n_sets, 0) + 1
    
    return frequency

def main():
    parser = argparse.ArgumentParser(description="Plot binomial distribution of sets in cards.")
    parser.add_argument("--max-workers", type=int, default=50, help="Maximum number of worker threads.")
    parser.add_argument("--start-range", type=int, default=3, help="Start of the range for number of cards.")
    parser.add_argument("--end-range", type=int, default=14, help="End of the range for number of cards (inclusive).")
    parser.add_argument("--n_samples", type=int, default=1000, help="Number of samples to take.")
    parser.add_argument("--server-url", type=str, default="http://127.0.0.1:8000/api/v1", help="URL of the set server.")
    args = parser.parse_args()

    for n_cards in range(args.start_range, args.end_range + 1):
        frequency = calculate_frequency(n_cards, args.n_samples, args.max_workers, args.server_url)

        plt.bar(frequency.keys(), frequency.values())
        plt.xlabel("Number of sets")
        plt.ylabel("Frequency")
        plt.title(f"Distribution of sets in {n_cards} cards ({args.n_samples} samples)")

        for n, freq in frequency.items():
            perc = freq / args.n_samples * 100
            plt.text(n, freq + 0.4, f"{perc:.3f}%", ha='center', va='bottom', fontsize=8)

        plt.xticks(list(frequency.keys()))
        plt.savefig(f"images/binom_{n_cards}_cards.png", dpi=300, bbox_inches='tight')
        plt.clf()

if __name__ == "__main__":
    main()



================================================
FILE: requirements.txt
================================================
fastapi
uvicorn



================================================
FILE: server.py
================================================
from fastapi import FastAPI
from fastapi.responses import JSONResponse, FileResponse
from fastapi import HTTPException
from fastapi import BackgroundTasks
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel
from typing import List
import uvicorn
import random
import sys
import os
import json
import itertools
import math
from uuid import uuid4

from balatro_set_classes import Joker, JokerTrigger, ConsumableTrigger, ScoreLogEntry, ScoringContext, ConsumableContext, GameContext, JokerVariant
from balatro_set_classes import Card, ShopSlot, PackOpeningChoice, PackOpeningState, BoosterPack, ShopState, GameState
from balatro_set_cards import JOKER_RARITY_PRICES, JOKER_VARIANT_PRICES_MULT
from balatro_set_core import get_current_blind_info, get_joker_by_name, get_random_joker_by_rarity, get_random_pack_rarity
from balatro_set_core import ANTE_CONFIG, PACK_RARITIES
from balatro_set_cards import JOKER_DATABASE, TAROT_DATABASE
from balatro_set_core import b_create_deck, b_is_set
from balatro_set_core import trigger_joker_abilities, trigger_consumable_abilities

app = FastAPI()
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

LEADERBOARD_FILE = "leaderboard.json"

N_DIMS = 4
N_VARS_PER_DIM = 3
N_CARDS_PER_SET = 3
N_CARDS_TO_DEAL = 12

DIM_NAMES = ["color", "shape", "number", "shading"]

GAME_SAVES: dict[str, GameState] = {}

if os.path.exists("balatro-saves.json"):
    with open("balatro-saves.json", "r") as f:
        data = json.load(f)
        for uid, game_data in data.items():
            joker_data = game_data.get("jokers", [])
            jokers: List['Joker'] = []
            for j in joker_data:
                if j["id"] in JOKER_DATABASE:
                    joker = JOKER_DATABASE[j["id"]].copy()
                    joker.variant = j["variant"]
                    jokers.append(joker)

            for idx in range(len(jokers)):
                jokers[idx].custom_data = joker_data[idx].get("custom_data", {})

            consumable_data = game_data.get("consumables", [])
            consumables = [TAROT_DATABASE[c["id"]].copy() for c in consumable_data if c["id"] in TAROT_DATABASE]
            game_state = GameState(
                id=uid,
                board_size=game_data.get("board_size", 12),
                base_board_size=game_data.get("base_board_size", 12),
                money=game_data.get("money", 4),
                boards_remaining=game_data.get("boards_remaining", 4),
                discards_remaining=game_data.get("discards_remaining", 3),
                ante=game_data.get("ante", 1),
                current_blind_index=game_data.get("current_blind_index", 0),
                game_phase=game_data.get("game_phase", "playing"),
                jokers=jokers,
                consumables=consumables,
                set_type_levels=game_data.get("set_type_levels", {}),
            )
            game_state.board = [Card(**card) for card in game_data.get("board", [])]
            game_state.deck = [Card(**card) for card in game_data.get("deck", [])]
            game_state.discard_pile = [Card(**card) for card in game_data.get("discard_pile", [])]
            game_state.round_score = game_data.get("round_score", 0)
            GAME_SAVES[uid] = game_state


class SetCard(BaseModel):
    color_val: int
    shape_val: int
    number_val: int
    shading_val: int

    def to_tuple(self) -> tuple[int, int, int, int]:
        return (self.color_val, self.shape_val, self.number_val, self.shading_val)
    
    def __hash__(self):
        return hash(self.to_tuple())

class DealRequest(BaseModel):
    n_cards: int = N_CARDS_TO_DEAL
    seed: int | str | None = None
    exclude: list[SetCard] | None = None

class Score(BaseModel):
    name: str
    score: int

def get_leaderboard_data() -> list[Score]:
    if not os.path.exists(LEADERBOARD_FILE):
        return []
    with open(LEADERBOARD_FILE, "r") as f:
        try:
            data = json.load(f)
            if not isinstance(data, list):
                return []
            return [Score(**item) for item in data]
        except (json.JSONDecodeError, TypeError):
            return []

def save_leaderboard_data(leaderboard: list[Score]):
    with open(LEADERBOARD_FILE, "w") as f:
        json.dump([item.dict() for item in leaderboard], f, indent=4)

def is_valid_set(cards: list[SetCard]) -> tuple[bool, str | None]:
    values = [card.to_tuple() for card in cards]
    for i in range(N_DIMS):
        dim_values = [value[i] for value in values]
        if not (all(v == dim_values[0] for v in dim_values) or len(set(dim_values)) == N_VARS_PER_DIM):
            return False, f"The {DIM_NAMES[i]}s are not all the same or all different."
    return True, None

@app.post("/api/v1/is_set")
async def is_set(cards: list[SetCard]):
    if len(cards) != N_CARDS_PER_SET:
        return JSONResponse(status_code=400, content={"message": f"Exactly {N_CARDS_PER_SET} cards must be provided."})

    is_valid, reason = is_valid_set(cards)
    if not is_valid:
        return JSONResponse(status_code=400, content={"ok": False, "message": reason})

    return JSONResponse(status_code=200, content={"ok": True})

@app.post("/api/v1/deal_cards")
async def deal_cards(request: DealRequest):
    if request.n_cards <= 0 or request.n_cards > N_VARS_PER_DIM ** N_DIMS:
        return JSONResponse(status_code=400, content={"message": f"Number of cards must be between 1 and {N_VARS_PER_DIM ** N_DIMS}."})
    
    if request.seed is not None:
        if isinstance(request.seed, str):
            request.seed = hash(request.seed)
        random.seed(request.seed)
    
    all_cards = [
        SetCard(color_val=color, shape_val=shape, number_val=number, shading_val=shading)
        for color in range(N_VARS_PER_DIM)
        for shape in range(N_VARS_PER_DIM)
        for number in range(N_VARS_PER_DIM)
        for shading in range(N_VARS_PER_DIM)
    ]

    all_cards = set(all_cards)
    if request.exclude:
        all_cards -= set(request.exclude)
    if len(all_cards) < request.n_cards:
        return JSONResponse(status_code=400, content={"message": "Not enough cards available to deal."})
    
    all_cards = list(all_cards)

    dealt_cards = random.sample(all_cards, request.n_cards)
    return JSONResponse(status_code=200, content={"cards": [card.dict() for card in dealt_cards], "ok": True})

@app.get("/api/v1/get_leaderboard")
async def get_leaderboard():
    return get_leaderboard_data()

@app.post("/api/v1/post_score")
async def post_score(score: Score):
    leaderboard = get_leaderboard_data()
    leaderboard.append(score)
    leaderboard.sort(key=lambda x: x.score, reverse=True)
    save_leaderboard_data(leaderboard)
    return {"ok": True}

@app.post("/api/v1/find_set")
async def find_set(cards: list[SetCard]):
    if len(cards) < N_CARDS_PER_SET:
        return JSONResponse(status_code=400, content={"message": f"At least {N_CARDS_PER_SET} cards must be provided."})

    for combo in itertools.combinations(cards, N_CARDS_PER_SET):
        if is_valid_set(list(combo))[0]:
            return JSONResponse(status_code=200, content={"set": [card.dict() for card in combo], "ok": True})

    return JSONResponse(status_code=404, content={"message": "No set found in the provided cards.", "ok": False})

@app.post("/api/v1/find_all_sets")
async def find_all_sets(cards: list[SetCard]):
    if len(cards) < N_CARDS_PER_SET:
        return JSONResponse(status_code=400, content={"message": f"At least {N_CARDS_PER_SET} cards must be provided."})

    found_sets = []
    for combo in itertools.combinations(cards, N_CARDS_PER_SET):
        if is_valid_set(list(combo))[0]:
            # Sort cards to have a canonical representation for each set
            sorted_combo = sorted(list(combo), key=lambda c: c.to_tuple())
            found_sets.append([card.dict() for card in sorted_combo])

    return JSONResponse(status_code=200, content={"sets": found_sets, "ok": True})

class PlaySetRequest(BaseModel): card_indices: list[int]
class BuyJokerRequest(BaseModel): slot_index: int
class SellJokerRequest(BaseModel): joker_index: int
class BuyBoosterRequest(BaseModel): slot_index: int
class ChoosePackRewardRequest(BaseModel): selected_ids: list[str]

class UseConsumableRequest(BaseModel):
    consumable_index: int
    target_card_indices: list[int] | None = None

class ReorderJokersRequest(BaseModel):
    new_order: list[int]

@app.post("/api/balatro/new_run", response_model=GameState)
async def new_run():
    deck_cards = [Card(attributes=attr) for attr in b_create_deck()]
    random.shuffle(deck_cards)
    current_game = GameState(
        board_size=12, base_board_size=12, money=4, boards_remaining=4, discards_remaining=3, ante=1,
        current_blind_index=0, game_phase="playing",
        jokers=[],
        set_type_levels={"3_uniform_1_ladder": 2, "2_uniform_2_ladder": 2, "1_uniform_3_ladder": 2, "0_uniform_4_ladder": 2}
    )
    current_game.board = deck_cards[:current_game.board_size]
    current_game.deck = deck_cards[current_game.board_size:]

    uid = str(uuid4())
    current_game.id = uid
    GAME_SAVES[uid] = current_game

    return JSONResponse(content=current_game.model_dump())

@app.get("/api/balatro/state")
async def get_state(id: str):
    
    if id not in GAME_SAVES:
        raise HTTPException(status_code=404, detail="Game not found.")
    current_game = GAME_SAVES[id]

    blind_info = get_current_blind_info(current_game)
    return {**current_game.model_dump(), "current_blind": blind_info["name"], "blind_score_required": blind_info["score_required"]}

@app.post("/api/balatro/play_set")
async def play_set(request: PlaySetRequest, id: str, background_tasks: BackgroundTasks):
    if id not in GAME_SAVES:
        raise HTTPException(status_code=404, detail="Game not found.")
    current_game = GAME_SAVES[id]

    if not current_game or current_game.game_phase != "playing":
        raise HTTPException(status_code=400, detail="Not in a playing phase.")
    if len(request.card_indices) != 3:
        raise HTTPException(status_code=400, detail="Must select exactly 3 cards.")
    if current_game.boards_remaining <= 0:
        raise HTTPException(status_code=400, detail="No boards remaining.")
    selected_cards = [current_game.board[i] for i in request.card_indices]
    if not b_is_set([card.attributes for card in selected_cards]):
        raise HTTPException(status_code=400, detail="Not a valid set.")

    attributes = [card.attributes for card in selected_cards]
    uniform_features, ladder_features = 0, 0
    for i in range(4):
        feature_values = {attrs[i] for attrs in attributes}
        if len(feature_values) == 1:
            uniform_features += 1
        elif len(feature_values) == 3:
            ladder_features += 1

    set_type_string = f"{uniform_features}_uniform_{ladder_features}_ladder"
    current_game.played_set_types.append(set_type_string)
    
    level = current_game.set_type_levels.get(set_type_string, 1)

    base_chips = (10 + (5 * uniform_features)) + (15 * (level - 1))
    base_mult = (1 + ladder_features * 2) * (1 + (level - 1) * 0.5)

    scoring_ctx = ScoringContext(
        base_chips=base_chips,
        base_mult=base_mult,
        flat_chips=0,
        additive_mult=0,
        multiplicative_mult=1,
        uniform_features=uniform_features,
        ladder_features=ladder_features,
        set_type_string=set_type_string,
        score_log=[],
        scoring_cards=selected_cards
    )

    # Log base set score
    scoring_ctx.score_log.append(ScoreLogEntry(
        source_type='set',
        source_name=f"Played Set ({uniform_features}U, {ladder_features}L)",
        description=f"Base score for a level {level} set.",
        chips_before=0, mult_before=0,
        chips_after=scoring_ctx.base_chips, mult_after=scoring_ctx.base_mult,
        trigger_phase="set_base"
    ))

    # Score each card individually, then trigger jokers for that card
    for card in selected_cards:
        # Set the current card being scored
        scoring_ctx.current_scoring_card = card
        
        card_scored = False
        chips_before = scoring_ctx.base_chips + scoring_ctx.flat_chips
        mult_before = (scoring_ctx.base_mult + scoring_ctx.additive_mult) * scoring_ctx.multiplicative_mult
        
        card_mult_modifier = 1.0

        if card.enhancement == "bonus_chips":
            scoring_ctx.flat_chips += 30
            scoring_ctx.score_log.append(ScoreLogEntry(
                source_type='card', source_name="Bonus Chips", description="+30 Chips",
                chips_before=chips_before, mult_before=mult_before,
                chips_after=scoring_ctx.base_chips + scoring_ctx.flat_chips, mult_after=mult_before,
                trigger_phase="card_scoring"
            ))
        elif card.enhancement == "bonus_mult":
            scoring_ctx.additive_mult += 2
            scoring_ctx.score_log.append(ScoreLogEntry(
                source_type='card', source_name="Bonus Mult", description="+2 Mult",
                chips_before=chips_before, mult_before=mult_before,
                chips_after=chips_before, mult_after=(scoring_ctx.base_mult + scoring_ctx.additive_mult) * scoring_ctx.multiplicative_mult,
                trigger_phase="card_scoring"
            ))
        elif card.enhancement == "x_mult":
            card_mult_modifier = 1.5
            # The effect is logged after all other card-specific triggers
        elif card.enhancement == "gold":
            current_game.money += 3
            scoring_ctx.score_log.append(ScoreLogEntry(
                source_type='card', source_name="Gold Card", description="+$3",
                chips_before=chips_before, mult_before=mult_before,
                chips_after=chips_before, mult_after=mult_before,
                trigger_phase="card_scoring"
            ))
        elif card.enhancement == "wildcard":
            # Wildcards provide no chips or mult, but can be part of any set
            scoring_ctx.score_log.append(ScoreLogEntry(
                source_type='card', source_name="Wildcard", description="Wildcard (no score)",
                chips_before=chips_before, mult_before=mult_before,
                chips_after=chips_before, mult_after=mult_before,
                trigger_phase="card_scoring"
            ))

        # Trigger jokers for this card
        trigger_joker_abilities(GameContext(game=current_game, scoring=scoring_ctx), JokerTrigger.ON_SCORE_CARD)

        # Apply card-specific multiplicative multipliers after jokers
        if card.enhancement == "x_mult":
            chips_before_x = scoring_ctx.base_chips + scoring_ctx.flat_chips
            mult_before_x = (scoring_ctx.base_mult + scoring_ctx.additive_mult) * scoring_ctx.multiplicative_mult
            scoring_ctx.multiplicative_mult *= card_mult_modifier
            scoring_ctx.score_log.append(ScoreLogEntry(
                source_type='card', source_name="X-Mult Card", description="x1.5 Mult",
                chips_before=chips_before_x, mult_before=mult_before_x,
                chips_after=chips_before_x, mult_after=(scoring_ctx.base_mult + scoring_ctx.additive_mult) * scoring_ctx.multiplicative_mult,
                trigger_phase="card_scoring"
            ))
        
        if card.enhancement == "amplify":
            # If this card amplifies, we need to double the chips of other enhancements
            chips_before_amplify = scoring_ctx.base_chips + scoring_ctx.flat_chips
            mult_before_amplify = (scoring_ctx.base_mult + scoring_ctx.additive_mult) * scoring_ctx.multiplicative_mult
            scoring_ctx.flat_chips *= 2
            scoring_ctx.additive_mult *= 2
            scoring_ctx.score_log.append(ScoreLogEntry(
                source_type='card', source_name="Amplified Card", description="Doubled Chips and Mult",
                chips_before=chips_before_amplify, mult_before=mult_before_amplify,
                chips_after=scoring_ctx.base_chips + scoring_ctx.flat_chips, mult_after=(scoring_ctx.base_mult + scoring_ctx.additive_mult) * scoring_ctx.multiplicative_mult,
                trigger_phase="card_scoring"
            ))

    # Clear the current scoring card before final triggers
    scoring_ctx.current_scoring_card = None
    
    # After all cards, trigger jokers for the end of scoring
    trigger_joker_abilities(GameContext(game=current_game, scoring=scoring_ctx), JokerTrigger.ON_SCORE_CALCULATION)

    chips = scoring_ctx.base_chips + scoring_ctx.flat_chips
    mult = (scoring_ctx.base_mult + scoring_ctx.additive_mult) * scoring_ctx.multiplicative_mult
    score_gained = int(chips * mult)
    current_game.round_score += score_gained

    current_game.discard_pile.extend(selected_cards)
    for i in sorted(request.card_indices, reverse=True):
        current_game.board.pop(i)

    draw_count = max(0, current_game.board_size - len(current_game.board))
    if len(current_game.deck) < draw_count:
        current_game.deck.extend(current_game.discard_pile)
        random.shuffle(current_game.deck)
        current_game.discard_pile = []

    new_cards = current_game.deck[:draw_count]
    current_game.board.extend(new_cards)
    current_game.deck = current_game.deck[draw_count:]
    current_game.boards_remaining -= 1

    blind_info = get_current_blind_info(current_game)
    if current_game.round_score >= blind_info["score_required"]:
        interest_cap = 5
        interest_earned = min(current_game.money // 5, interest_cap)
        current_game.money += interest_earned

        trigger_joker_abilities(GameContext(game=current_game), JokerTrigger.ON_END_OF_ROUND)

        current_game.game_phase = "shop"
        current_game.money += 3 + current_game.boards_remaining
        current_game.shop_state = ShopState()
        available_jokers = [j for j in JOKER_DATABASE.values() if j.name not in {j.name for j in current_game.jokers}]
        
        num_jokers_to_add = min(2, len(available_jokers))
        for _ in range(num_jokers_to_add):
            if not available_jokers:
                break
            
            joker_to_add = get_random_joker_by_rarity(available_jokers)
            if not joker_to_add:
                continue

            available_jokers = [j for j in available_jokers if j.name != joker_to_add.name]

            price = math.ceil(JOKER_RARITY_PRICES.get(joker_to_add.rarity, 4) * JOKER_VARIANT_PRICES_MULT[joker_to_add.variant])
            current_game.shop_state.joker_slots.append(ShopSlot(item=joker_to_add, price=price))
        current_game.shop_state.booster_pack_slots.append(BoosterPack(name="Celestial Pack", price=4))
        current_game.shop_state.booster_pack_slots.append(BoosterPack(name="Tarot Pack", price=3))
    elif current_game.boards_remaining <= 0:
        current_game.game_phase = "game_over"

    game_state_dict = current_game.model_dump()
    game_state_dict["current_blind"] = blind_info["name"]
    game_state_dict["blind_score_required"] = blind_info["score_required"]

    final_scoring_details = {
        "chips": chips,
        "mult": mult,
        "score_gained": score_gained,
        "score_log": [log.model_dump() for log in scoring_ctx.score_log]
    }

    background_tasks.add_task(save_game_saves)

    return {"game_state": game_state_dict, "scoring_details": final_scoring_details}

class DiscardRequest(BaseModel): card_indices: list[int]

@app.post("/api/balatro/discard")
async def discard(request: DiscardRequest, id: str):
    if id not in GAME_SAVES:
        raise HTTPException(status_code=404, detail="Game not found.")
    
    current_game = GAME_SAVES[id]

    if not current_game or current_game.game_phase != "playing": raise HTTPException(status_code=400, detail="Not in a playing phase.")
    if not (1 <= len(request.card_indices) <= 5): raise HTTPException(status_code=400, detail="Must select between 1 and 5 cards to discard.")
    if current_game.discards_remaining <= 0: raise HTTPException(status_code=400, detail="No discards remaining.")
    
    selected_cards = [current_game.board[i] for i in request.card_indices]
    current_game.discard_pile.extend(selected_cards)
    for i in sorted(request.card_indices, reverse=True):
        current_game.board.pop(i)
    
    trigger_joker_abilities(GameContext(game=current_game, selected_card_indices=request.card_indices), JokerTrigger.ON_DISCARD)

    draw_count = max(0, current_game.board_size - len(current_game.board))
    if len(current_game.deck) < draw_count:
        current_game.deck.extend(current_game.discard_pile)
        random.shuffle(current_game.deck)
        current_game.discard_pile = []
    
    new_cards = current_game.deck[:draw_count]
    current_game.board.extend(new_cards)
    current_game.deck = current_game.deck[draw_count:]
    current_game.discards_remaining -= 1
    
    blind_info = get_current_blind_info(current_game)
    game_state_dict = current_game.model_dump()
    game_state_dict["current_blind"] = blind_info["name"]
    game_state_dict["blind_score_required"] = blind_info["score_required"]
    return {"game_state": game_state_dict}

@app.post("/api/balatro/buy_joker")
async def buy_joker(request: BuyJokerRequest, id: str):
    
    if id not in GAME_SAVES:
        raise HTTPException(status_code=404, detail="Game not found.")
    current_game = GAME_SAVES[id]

    if not current_game or current_game.game_phase != "shop": raise HTTPException(status_code=400, detail="Not in a shop phase.")
    if len(current_game.jokers) >= current_game.joker_slots: raise HTTPException(status_code=400, detail="No empty joker slots.")
    slot_index = request.slot_index
    if not (0 <= slot_index < len(current_game.shop_state.joker_slots)): raise HTTPException(status_code=400, detail="Invalid shop slot.")
    slot = current_game.shop_state.joker_slots[slot_index]
    if slot.is_purchased: raise HTTPException(status_code=400, detail="Item already purchased.")
    if current_game.money < slot.price: raise HTTPException(status_code=400, detail="Not enough money.")
    
    joker_to_buy = slot.item.copy()

    for ability_def in joker_to_buy.abilities:
        if ability_def.trigger == JokerTrigger.ON_BUY_SELF:
            ability_def.ability(joker_to_buy, GameContext(game=current_game))
            
    current_game.money -= slot.price
    current_game.jokers.append(joker_to_buy)
    """ if slot.item.variant == JokerVariant.NEGATIVE:
        current_game.joker_slots += 1 """
    slot.is_purchased = True
    trigger_joker_abilities(GameContext(game=current_game), JokerTrigger.ON_BUY_JOKER)
    return {"game_state": current_game.model_dump()}

@app.post("/api/balatro/sell_joker")
async def sell_joker(request: SellJokerRequest, id: str):
    if id not in GAME_SAVES:
        raise HTTPException(status_code=404, detail="Game not found.")
    current_game = GAME_SAVES[id]

    if not current_game or current_game.game_phase != "shop":
        raise HTTPException(status_code=400, detail="Can only sell jokers during the shop phase.")
    
    joker_index = request.joker_index
    if not (0 <= joker_index < len(current_game.jokers)):
        raise HTTPException(status_code=400, detail="Invalid joker index.")

    joker_to_sell = current_game.jokers.pop(joker_index)
    # Trigger destroy-self abilities for the sold joker
    for ability_def in joker_to_sell.abilities:
        if ability_def.trigger == JokerTrigger.ON_DESTROY_SELF:
            ability_def.ability(joker_to_sell, GameContext(game=current_game))
    # Sell price is half of the rarity price, rounded down
    sell_price = math.ceil(JOKER_RARITY_PRICES.get(joker_to_sell.rarity, 4) * JOKER_VARIANT_PRICES_MULT[joker_to_sell.variant]) // 2
    current_game.money += sell_price
    """ if joker_to_sell.variant == JokerVariant.NEGATIVE:
        current_game.joker_slots -= 1 """
    trigger_joker_abilities(GameContext(game=current_game), JokerTrigger.ON_DESTROY_JOKER)
    return {"game_state": current_game.model_dump(), "message": f"Sold {joker_to_sell.name} for ${sell_price}."}

@app.post("/api/balatro/buy_booster_pack")
async def buy_booster_pack(request: BuyBoosterRequest, id: str):
    if id not in GAME_SAVES:
        raise HTTPException(status_code=404, detail="Game not found.")
    current_game = GAME_SAVES[id]
    
    if not current_game or current_game.game_phase != "shop": raise HTTPException(status_code=400, detail="Not in a shop phase.")
    slot_index = request.slot_index
    if not (0 <= slot_index < len(current_game.shop_state.booster_pack_slots)): raise HTTPException(status_code=400, detail="Invalid pack slot.")
    pack = current_game.shop_state.booster_pack_slots[slot_index]
    if pack.is_purchased: raise HTTPException(status_code=400, detail="Pack already purchased.")
    if current_game.money < pack.price: raise HTTPException(status_code=400, detail="Not enough money.")
    
    current_game.money -= pack.price
    pack.is_purchased = True
    
    rarity = get_random_pack_rarity()
    rarity_info = PACK_RARITIES[rarity]
    
    choices = []
    if pack.name == "Celestial Pack":
        # Filter out the "4 Uniform, 0 Ladder" set type as it's practically unachievable.
        all_set_types = [st for st in current_game.set_type_levels.keys() if st != "4_uniform_0_ladder"]
        random.shuffle(all_set_types)
        
        # Ensure we don't try to show more choices than available
        num_to_show = min(rarity_info['show'], len(all_set_types))

        for type_key in all_set_types[:num_to_show]:
            level = current_game.set_type_levels[type_key]
            name = type_key.replace("_", " ").replace("ladder", "L").replace("uniform", "U")
            choices.append(PackOpeningChoice(id=type_key, name=f"Level up {name}", description=f"From Level {level} to {level + 1}"))
    elif pack.name == "Tarot Pack":
        if len(current_game.consumables) >= current_game.consumable_slots:
            current_game.money += pack.price # Refund
            pack.is_purchased = False
            raise HTTPException(status_code=400, detail="Not enough consumable slots to open pack.")
        
        available_tarots = list(TAROT_DATABASE.items())
        
        pack_choices = []
        for _ in range(rarity_info['show']):
            if not available_tarots:
                break
            
            result = random.choice(available_tarots)
            if not result:
                continue
            chosen_key, chosen_card = result
            
            pack_choices.append(PackOpeningChoice(id=chosen_key, name=chosen_card.name, description=chosen_card.description))
            
            available_tarots = [(k, c) for k, c in available_tarots if k != chosen_key]
        choices = pack_choices

    current_game.pack_opening_state = PackOpeningState(
        pack_type=pack.name,
        choices=choices,
        rarity=rarity,
        choose=rarity_info['choose']
    )
    current_game.game_phase = "pack_opening"
    
    return {"game_state": current_game.model_dump()}

@app.post("/api/balatro/choose_pack_reward")
async def choose_pack_reward(request: ChoosePackRewardRequest, id: str):
    if id not in GAME_SAVES:
        raise HTTPException(status_code=404, detail="Game not found.")
    current_game = GAME_SAVES[id]
    if not current_game or current_game.game_phase != "pack_opening":
        raise HTTPException(status_code=400, detail="Not in pack opening phase.")
    
    pack_state = current_game.pack_opening_state
    if len(request.selected_ids) > pack_state.choose:
        raise HTTPException(status_code=400, detail=f"Can only choose up to {pack_state.choose} rewards.")

    message = ""
    if pack_state.pack_type == "Celestial Pack":
        upgraded_names = []
        for type_key in request.selected_ids:
            current_game.set_type_levels[type_key] += 1
            upgraded_names.append(type_key.replace("_", " ").replace("ladder", "L").replace("uniform", "U"))
        message = f"Upgraded: {', '.join(upgraded_names)}!"
    elif pack_state.pack_type == "Tarot Pack":
        gained_cards = []
        for card_key in request.selected_ids:
            if len(current_game.consumables) < current_game.consumable_slots:
                card = TAROT_DATABASE[card_key]
                current_game.consumables.append(card)
                gained_cards.append(card.name)
        message = f"Gained: {', '.join(gained_cards)}!"

    current_game.pack_opening_state = None
    current_game.game_phase = "shop"
    
    return {"game_state": current_game.model_dump(), "message": message}

@app.post("/api/balatro/use_consumable")
async def use_consumable(request: UseConsumableRequest, id: str):
    if id not in GAME_SAVES:
        raise HTTPException(status_code=404, detail="Game not found.")
    current_game = GAME_SAVES[id]

    if not current_game or current_game.game_phase != "playing": raise HTTPException(status_code=400, detail="Can only use consumables during a round.")
    index = request.consumable_index
    if not (0 <= index < len(current_game.consumables)): raise HTTPException(status_code=400, detail="Invalid consumable index.")
    
    consumable = current_game.consumables[index] # Don't pop yet

    # Validation for target count
    if consumable.target_count > 0:
        if not request.target_card_indices or len(request.target_card_indices) != consumable.target_count:
            raise HTTPException(status_code=400, detail=f"This consumable requires selecting {consumable.target_count} card(s).")

    # Now pop it
    consumable = current_game.consumables.pop(index)
    current_game.last_consumable_used = consumable
    
    consumable_ctx = ConsumableContext(game=current_game, message=f"Used {consumable.name}.")
    game_ctx = GameContext(
        game=current_game,
        consumable=consumable_ctx,
        selected_card_indices=request.target_card_indices or []
    )
    trigger_consumable_abilities(current_game, consumable, ConsumableTrigger.ON_USE, game_ctx)
    # Trigger jokers on consumable use
    trigger_joker_abilities(game_ctx, JokerTrigger.ON_CONSUMABLE_USE)
    return {"game_state": current_game.model_dump(), "message": game_ctx.consumable.message}

@app.post("/api/balatro/reorder_jokers")
async def reorder_jokers(request: ReorderJokersRequest, id: str):
    if id not in GAME_SAVES:
        raise HTTPException(status_code=404, detail="Game not found.")
    current_game = GAME_SAVES[id]

    if not current_game or current_game.game_phase not in ["playing", "shop"]:
        raise HTTPException(status_code=400, detail="Can only reorder jokers during playing or shop phase.")

    new_order_indices = request.new_order
    jokers = current_game.jokers

    if len(new_order_indices) != len(jokers) or set(new_order_indices) != set(range(len(jokers))):
        raise HTTPException(status_code=400, detail="Invalid new order provided.")

    reordered_jokers = [jokers[i] for i in new_order_indices]
    current_game.jokers = reordered_jokers

    # No need to return the full game state, just a success message is fine
    # to reduce network traffic, but returning state is also okay.
    return {"game_state": current_game.model_dump()}

@app.post("/api/balatro/leave_shop")
async def leave_shop(id: str):
    if id not in GAME_SAVES:
        raise HTTPException(status_code=404, detail="Game not found.")
    current_game = GAME_SAVES[id]

    if not current_game or current_game.game_phase != "shop": raise HTTPException(status_code=400, detail="Not in a shop phase.")
    
    current_game.current_blind_index += 1
    if current_game.current_blind_index >= len(ANTE_CONFIG[current_game.ante]["names"]):
        current_game.ante += 1
        current_game.current_blind_index = 0
        if current_game.ante > max(ANTE_CONFIG.keys()):
            current_game.game_phase = "run_won"
            return {"game_state": current_game.model_dump()}
    
    current_game.game_phase = "playing"
    current_game.round_score = 0
    current_game.boards_remaining = current_game.boards_per_round
    current_game.discards_remaining = current_game.discards_per_round
    current_game.played_set_types = []
    current_game.board_size = current_game.base_board_size

    # Reshuffle all cards back into the deck
    all_cards = current_game.deck + current_game.board + current_game.discard_pile
    random.shuffle(all_cards)
    
    current_game.board = all_cards[:current_game.board_size]
    current_game.deck = all_cards[current_game.board_size:]
    current_game.discard_pile = []
    
    ante_info = ANTE_CONFIG.get(current_game.ante, {})
    boss_effects = ante_info.get("boss_effects")
    current_game.boss_blind_effect = boss_effects[current_game.current_blind_index] if boss_effects and current_game.current_blind_index < len(boss_effects) else None
    
    if current_game.boss_blind_effect == "reduce_board_size":
        current_game.board_size = 9
        if len(current_game.board) > current_game.board_size:
            cards_to_discard_count = len(current_game.board) - current_game.board_size
            cards_to_discard = random.sample(current_game.board, cards_to_discard_count)
            current_game.discard_pile.extend(cards_to_discard)
            current_game.board = [card for card in current_game.board if card not in cards_to_discard]
    
    blind_info = get_current_blind_info(current_game)
    game_state_dict = current_game.model_dump()
    game_state_dict["current_blind"] = blind_info["name"]
    game_state_dict["blind_score_required"] = blind_info["score_required"]

    trigger_joker_abilities(GameContext(game=current_game), JokerTrigger.ON_START_ROUND) #May not work correctly
    return {"game_state": game_state_dict}

@app.post("/api/balatro/set_money", include_in_schema=False)
async def set_money(id: str, amount: int):
    if id not in GAME_SAVES:
        raise HTTPException(status_code=404, detail="Game not found.")
    current_game = GAME_SAVES[id]
    current_game.money = amount
    return {"game_state": current_game.model_dump()}

@app.post("/api/balatro/give_joker", include_in_schema=False)
async def give_joker(id: str, joker_id: str):
    from balatro_set_core import JOKER_DATABASE
    if id not in GAME_SAVES:
        raise HTTPException(status_code=404, detail="Game not found.")
    current_game = GAME_SAVES[id]
    if joker_id not in JOKER_DATABASE:
        raise HTTPException(status_code=400, detail="Invalid joker id.")
    if len(current_game.jokers) >= current_game.joker_slots:
        raise HTTPException(status_code=400, detail="No empty joker slots.")
    joker = JOKER_DATABASE[joker_id].copy()
    current_game.jokers.append(joker)
    return {"game_state": current_game.model_dump()}

@app.post("/api/balatro/give_tarot", include_in_schema=False)
async def give_tarot(id: str, tarot_id: str):
    from balatro_set_core import TAROT_DATABASE
    if id not in GAME_SAVES:
        raise HTTPException(status_code=404, detail="Game not found.")
    current_game = GAME_SAVES[id]
    if tarot_id not in TAROT_DATABASE:
        raise HTTPException(status_code=400, detail="Invalid tarot id.")
    if len(current_game.consumables) >= current_game.consumable_slots:
        raise HTTPException(status_code=400, detail="No empty consumable slots.")
    tarot = TAROT_DATABASE[tarot_id]
    current_game.consumables.append(tarot)
    return {"game_state": current_game.model_dump()}

@app.get("/api/balatro/saves")
async def get_saves():
    blind_infos = []
    for uid, game in GAME_SAVES.items():
        blind_info = get_current_blind_info(game)
        blind_infos.append({
            "id": uid,
            "current_blind": blind_info["name"],
            "blind_score_required": blind_info["score_required"],
            "round_score": game.round_score,
            "game_phase": game.game_phase,
            "ante": game.ante,
            "money": game.money
        })
    return {"saves": blind_infos}

@app.delete("/api/balatro/saves/{id}")
async def delete_save(id: str):
    if id not in GAME_SAVES:
        raise HTTPException(status_code=404, detail="Save not found.")
    del GAME_SAVES[id]
    save_game_saves()
    return {"ok": True, "message": f"Deleted save {id}"}

def save_game_saves():
    print("Saving game saves...")

    with open("balatro-saves.json", "w") as f:
        json.dump({uid: game.model_dump() for uid, game in GAME_SAVES.items()}, f, indent=4)


@app.get("/{path:path}")
async def serve_file(path: str):
    if path == "":
        path = "index.html"
    file_path = os.path.join("static", path)
    if os.path.exists(file_path):
        return FileResponse(file_path)
    else:
        return JSONResponse(status_code=404, content={"message": "File not found"})

if __name__ == "__main__":
    port = 8000
    if len(sys.argv) > 1:
        port = int(sys.argv[1])
    uvicorn.run(app, host="0.0.0.0", port=port)



================================================
FILE: docs/attributes.md
================================================
# attributes.md

card: tuple[int, int, int, int]

(color, shape, number, shading)
   0      1      2        3


## color
- 0: red
- 1: purple
- 2: green

## shape
- 0: ellipse
- 1: triangle
- 2: rectangle

## number
- 0: one
- 1: two
- 2: three

## shading
- 0: solid
- 1: striped
- 2: open






================================================
FILE: docs/balatro-gamemode.md
================================================
Of course. Here is a comprehensive game design document outline for recreating Balatro, focusing on the systems, mechanics, and loops for an experienced developer. This document describes the *what* and the *how* of the systems, leaving specific numerical values for balancing and playtesting.

***

## Balatro: Game Design & Systems Document

### 1. Game Overview

*   **Concept:** A poker-themed, roguelike deck-builder where players build powerful synergistic engines to score massive points and defeat escalating challenges.
*   **Core Fantasy:** Turning a standard 52-card deck into an absurd, score-generating machine through strategic card acquisition and engine-building.
*   **Genre:** Roguelike, Deck-builder, Strategy.
*   **Winning Condition:** Successfully defeat the Boss Blind of Ante 8.
*   **Losing Condition:** Fail to meet the required score for any Blind.

### 2. Core Gameplay Loops

The game operates on three nested loops:

#### 2.1 The Micro Loop: Playing a Round
*This is the moment-to-moment gameplay of scoring points within a single Blind.*

1.  **Draw:** Player draws cards from their Draw Pile up to their maximum Hand Size.
2.  **Select & Play:** Player selects 1-5 cards from their hand to form a Poker Hand and clicks "Play Hand".
3.  **Scoring:** The played hand is evaluated.
    *   The game calculates **Chips** (base score) and **Mult** (multiplier) from the hand's rank (e.g., Pair, Flush).
    *   All active effects (from Jokers, card enhancements, etc.) are triggered in a specific order to modify the Chips and Mult values.
    *   The final score is calculated: `Score = Chips x Mult`.
    *   The calculated score is added to the player's total for the current Blind.
4.  **Discard:** Played cards go to the Discard Pile. The Player's "Hands Played" counter decrements.
5.  **Repeat or Discard:**
    *   If the score requirement for the Blind is not yet met and the player has "Hands" remaining, they can choose to:
        *   **A) Play another hand:** Return to step 2.
        *   **B) Discard:** Select 1-5 cards to move to the Discard Pile. This consumes a "Discards" resource. The player then re-draws up to their Hand Size. Return to step 2.
6.  **Round End:** The round ends when either:
    *   The score requirement is met (Win).
    *   The player runs out of "Hands" to play before meeting the score (Loss).

#### 2.2 The Macro Loop: The Ante
*This is the primary loop of progression within a single run.*

1.  **Start of Ante:** The player begins an Ante, which consists of three Blinds: Small Blind, Big Blind, and the Boss Blind.
2.  **Small Blind:** Player engages in the Micro Loop to beat the Small Blind's score requirement.
    *   **On Win:** Player receives a base cash reward + bonus cash for any unused "Hands". The player proceeds to the Shop.
    *   **On Loss:** The run ends.
3.  **Shop Phase:** The player can spend cash ($) on upgrades. (See Section 4.5 The Shop). After exiting the shop, they proceed to the next Blind.
4.  **Big Blind:** Player engages in the Micro Loop to beat the Big Blind's score requirement.
    *   **On Win:** Player receives cash reward and proceeds to the Shop.
    *   **On Loss:** The run ends.
5.  **Shop Phase:** Another opportunity to spend cash.
6.  **Boss Blind:** Player engages in the Micro Loop to beat the Boss Blind's score requirement. This Blind has a unique, challenging modifier that alters game rules for that round only.
    *   **On Win:** Player receives a larger cash reward, an "Ante Bonus" (e.g., +1 Joker slot, +$X), and advances to the next, more difficult Ante.
    *   **On Loss:** The run ends.

#### 2.3 The Meta Loop: Run-to-Run Progression
*This loop covers the player's progression across multiple game sessions.*

1.  **Start New Run:** Player selects a Deck and a Stake (difficulty level).
2.  **Play Run:** Player progresses through the Macro Loop (Antes).
3.  **Run End (Win/Loss):** The run concludes.
4.  **Unlocks:** Based on in-run achievements (e.g., winning with a specific deck, reaching a certain Ante, scoring a specific hand), new game content is unlocked. This includes:
    *   New Decks
    *   New Jokers
    *   New Vouchers
    *   Higher Stakes (difficulties)
5.  **Return to Main Menu:** The player can start a new run with more options available, creating a new experience.

### 3. Core Game Mechanics & Systems

#### 3.1 The Scoring Formula
This is the mathematical heart of the game. It must be processed in a strict order.

*   **Base Values:** Every Poker Hand has a base **Chip** value and a base **Mult** value. These values can be increased by Planet cards.
*   **Formula:** `Score = ( (Base_Chips + Flat_Chips) x (Base_Mult + Additive_Mult) ) x Multiplicative_Mult`
    *   **`Base_Chips`**: Chips from cards played (e.g., a '10' card adds 10 chips) and the base value of the Poker Hand.
    *   **`Flat_Chips`**: All chip bonuses from Jokers and other effects that say "+X Chips".
    *   **`Base_Mult`**: The base multiplier from the Poker Hand.
    *   **`Additive_Mult`**: All multiplier bonuses from Jokers and other effects that say "+X Mult".
    *   **`Multiplicative_Mult`**: All multiplier bonuses from Jokers and other effects that say "xX Mult". These are multiplied together, not added. `(x2 Mult) * (x1.5 Mult) = x3 Mult`.

#### 3.2 Player Stats
These are the core numerical attributes of the player for a given run.

*   **Hands:** Number of times the player can play a hand per round. (Default: 4)
*   **Discards:** Number of times the player can discard cards per round. (Default: 3)
*   **Money ($):** Currency for the shop. Earned from winning Blinds, interest, and card effects.
*   **Interest:** At the end of a round, the player earns $1 for every $5 they possess, up to a cap.
*   **Hand Size:** Max number of cards in hand. (Default: 8)
*   **Joker Slots:** Max number of Jokers the player can hold. (Default: 5)

#### 3.3 Card Types & Properties

1.  **Playing Cards:**
    *   **Base:** Standard 52-card deck (13 Ranks, 4 Suits).
    *   **Enhancements:** Permanent modifications on a single card.
        *   *Examples: Bonus Card (+Chips), Mult Card (+Mult), Wild Card (can be any suit), Glass Card (xMult but shatters), Steel Card (xMult that persists in hand), etc.*
    *   **Editions:** A special modifier applied to a card (Joker or Playing Card) that grants a passive bonus.
        *   *Examples: Foil (Flat Chips), Holographic (Flat Mult), Polychrome (xMult).*
    *   **Seals:** A stamp on a card that triggers a one-time effect when the card is scored.
        *   *Examples: Gold Seal (gives money), Red Seal (re-triggers the card), Blue Seal (creates a Planet card), Purple Seal (creates a Tarot card).*

2.  **Jokers:**
    *   **Function:** The primary engine-building component. They provide passive abilities that modify the scoring formula or game rules. They sit in Joker Slots.
    *   **Effect Categories (for design purposes):**
        *   **Scoring Modifiers:** Affect Chips, Additive Mult, or Multiplicative Mult.
        *   **Triggered Effects:** Activate on certain events (e.g., playing a specific suit, discarding, playing a specific hand, selling a Joker).
        *   **Economic:** Affect money, interest, or shop prices.
        *   **Card Manipulation:** Affect drawing, hand size, or creating other cards.
        *   **Rule Bending:** Change fundamental rules (e.g., allow Flushes with 4 cards).

3.  **Consumables:**
    *   **Tarot Cards:** Single-use cards that provide immediate effects, such as enhancing playing cards, creating Jokers, giving money, or duplicating cards.
    *   **Planet Cards (Celestial Packs):** Single-use cards that permanently (for the run) level up a specific Poker Hand, increasing its base Chips and Mult.
    *   **Spectral Cards:** Single-use, high-risk/high-reward cards that offer powerful but often costly or unpredictable modifications to the player's run (e.g., destroy a Joker to gain a powerful bonus).

#### 3.4 Deck & Hand Management
*   The player's deck is a persistent collection of cards for the run.
*   **Draw Pile:** Cards waiting to be drawn. Reshuffled from the Discard Pile when empty.
*   **Discard Pile:** Cards that have been played or discarded.
*   The deck can be modified by adding or removing cards via Tarot, Spectral, and other effects.

### 4. Game Structure & Content

#### 4.1 Decks
*   The player chooses one Deck at the start of a run. Each deck provides a unique starting bonus.
*   *Examples: Red Deck (+1 Discard), Blue Deck (+1 Hand), Yellow Deck (+$10 starting money), Black Deck (+1 Joker Slot but -1 Hand).*

#### 4.2 Antes & Blinds
*   The game is structured into 8 Antes.
*   Each Ante has a Small Blind, Big Blind, and Boss Blind.
*   The score requirements for Blinds scale exponentially with each Ante.
*   *e.g., Ante 1: 300 / 450 / 600. Ante 8: ~100k+*

#### 4.3 Boss Blinds
*   A key feature to challenge established engines. Each Boss Blind has a unique negative modifier for that round.
*   **Modifier Categories (for design purposes):**
    *   **Card Debuffs:** *e.g., "All Heart cards are debuffed (drawn face down)."*
    *   **Hand Restrictions:** *e.g., "Player can only play one hand."*
    *   **Economic Restrictions:** *e.g., "Sell value of all items is $0."*
    *   **Joker Disruption:** *e.g., "One random Joker is disabled for this round."*

#### 4.4 Poker Hands
*   A list of standard poker hands must be defined, each with a base Chip and Mult value.
*   *List: High Card, Pair, Two Pair, Three of a Kind, Straight, Flush, Full House, Four of a Kind, Straight Flush, Royal Flush.*
*   The game needs a system to detect the highest-ranking hand from a set of 1-5 cards.
*   The level-up system via Planet Cards must track the level of each hand type independently.

#### 4.5 The Shop
*   The central hub for run improvement.
*   The shop presents a semi-randomized selection of items for purchase.
*   **Standard Shop Slots:**
    *   2 slots for Jokers.
    *   2 slots for Booster Packs (Tarot, Planet, Standard, etc.).
*   **Permanent Shop Slot:**
    *   1 slot for Vouchers.
*   **Functionality:**
    *   **Purchase:** Spend $ to buy an item.
    *   **Sell:** Sell owned Jokers for a fraction of their base price.
    *   **Reroll:** Spend an increasing amount of $ to refresh the shop's offerings (excluding Vouchers).
*   **Vouchers:** Permanent, run-long upgrades. Only two can be bought per Ante.
    *   *Examples: Increase hand size, add a Joker slot, improve shop offerings.*
*   **Booster Packs:** When purchased, they open to reveal a selection of cards (e.g., a Tarot Pack shows 2 Tarot cards, player picks 1).

### 5. Meta-Progression & Unlocks
*   A master list of all content (Jokers, Decks, Vouchers, etc.) is required.
*   Each item has an "unlocked" state (true/false). Initially, only a small subset is unlocked.
*   Each locked item has one or more unlock conditions.
    *   *Examples: "Win a run with the Blue Deck" unlocks a new Joker. "Reach Ante 6" unlocks a new Voucher.*
*   **Stakes (Difficulty):** A linear series of difficulty modifiers.
    *   Winning a run on the current highest Stake with a specific Deck unlocks the next Stake for that Deck.
    *   *Examples of Stake Modifiers: Increased Blind scaling, decreased sell value, Perishable Jokers (debuff after a few rounds), eternal Boss Blind effects.*

### 6. Technical & UI/UX Considerations

#### 6.1 Data-Driven Design
*   All game objects—Jokers, cards, enhancements, bosses, vouchers—should be implemented as data assets (e.g., Scriptable Objects in Unity, or JSON/XML files).
*   This allows for easy balancing, content creation, and modification without touching core game logic.
*   Each object's data would define its name, art, cost, and effect parameters.

#### 6.2 Event-Based Architecture
*   A robust event system is critical for managing Joker triggers.
*   Instead of hard-coding checks, the game should fire global events like `OnCardPlayed`, `OnHandScored`, `OnDiscard`, `OnShopEntered`, `OnBlindWon`.
*   Jokers and other game elements would "subscribe" to these events and execute their logic when the event is fired. This makes the system extremely modular and scalable.

#### 6.3 RNG & Seeding
*   The entire run must be reproducible from a single seed string.
*   This seed must govern: initial deck shuffle, all subsequent card draws, all shop offerings, all booster pack contents, and any probabilistic effects from cards/Jokers.
*   This is essential for debugging, community challenges, and run sharing.

#### 6.4 UI Flow & Key Screens
*   **Main Menu:** New Run, Continue Run, Collection, Settings, Exit.
*   **Run Setup:** Deck Selection -> Stake Selection.
*   **Gameplay Screen:**
    *   **Top:** Current Blind, Score Required / Current Score, Money, Ante #.
    *   **Center:** Hand of cards.
    *   **Bottom:** Play/Discard buttons, Hands/Discards remaining, Draw/Discard piles.
    *   **Side/Top:** Joker area, displaying active Jokers and their effects.
*   **Shop Screen:** Clear layout with slots for Jokers, Packs, and Vouchers. Reroll button and current money are always visible.
*   **Collection Screen:** A grid or list showing all discovered items, with tooltips revealing their effects and unlock conditions for those not yet unlocked.
*   **Run Summary Screen:** Displays key stats upon run completion (final score, Ante reached, most played hand, most valuable Joker, etc.).


================================================
FILE: docs/balatro-scoring.md
================================================
# Balatro Scoring System

The scoring system in Balatro mode is based on the attributes of the three cards that form a valid Set. When a player successfully plays a Set, points are calculated based on "chips" and "multiplier" values, which are derived from how many features of the cards are uniform or form a "ladder" (all different).

## Scoring Calculation

1.  **Feature Analysis:** For each of the four card attributes (color, shape, number, shading), the system checks the selected three cards:
    *   **Uniform Features:** If all three cards have the *same* value for a particular attribute (e.g., all cards are red), it counts as a "uniform feature".
    *   **Ladder Features:** If all three cards have *different* values for a particular attribute (e.g., one red, one green, one purple), it counts as a "ladder feature". (Note: By definition of a Set, an attribute must either be all the same or all different across the three cards).

2.  **Base Values:**
    *   `base_chips` starts at `10`.
    *   `base_mult` starts at `1`.

3.  **Chips Calculation:**
    *   `chips = base_chips + (5 * uniform_features)`
    *   Each "uniform" feature (all same) adds 5 to the base chips.

4.  **Multiplier Calculation:**
    *   `mult = base_mult * (2 ** ladder_features)`
    *   Each "ladder" feature (all different) doubles the multiplier, creating an exponential growth in score for sets with many different features.

5.  **Score Gained:**
    *   `score_gained = chips * mult`
    *   The total score gained from playing a Set is the calculated `chips` multiplied by the calculated `mult`.

6.  **Round Score Update:**
    *   The `score_gained` is added to the `current_game.round_score`.

## Example

If a played Set has:
*   2 uniform features (e.g., all same color, all same shape)
*   2 ladder features (e.g., all different numbers, all different shading)

Then:
*   `chips = 10 + (5 * 2) = 20`
*   `mult = 1 * (2 ** 2) = 4`
*   `score_gained = 20 * 4 = 80`

This `80` would then be added to the player's current `round_score`. The goal is to reach `blind_score_required` to win the round.



================================================
FILE: docs/balatro-todo.md
================================================
# Balatro-Set Adaptation: Feature To-Do List

This document outlines the features missing from the current implementation to fully adapt the Balatro-style macro loop and abilities for a game using "Set" cards as the core micro-loop. The analysis is based on the existing code and the `balatro-gamemode.md` design document.

### 1. Core Gameplay & Scoring System

The current scoring is a simple `chips * mult`. It needs to be expanded to support the complex interactions required by a Balatro-like game.

*   **Implement Full Scoring Formula:** Refactor the server's scoring logic in `balatro-server.py` to use the extensible formula: `Score = ( (Base_Chips + Flat_Chips) x (Base_Mult + Additive_Mult) ) x Multiplicative_Mult`. This is critical for Joker and other item effects to work correctly.
*   **Design "Planet Card" Equivalent:** The concept of leveling up poker hands needs a "Set" equivalent. This system must be designed and implemented.
    *   **Proposal:** Create "Celestial Cards" that level up the scoring for specific Set combinations (e.g., "Sets with 3 uniform features", "Sets with 2 ladder and 2 uniform features", etc.).
    *   This requires tracking the "level" of each Set type in the `GameState`.
*   **Implement Interest:** Add the money interest mechanic on the server, granting bonus money at the end of a round based on the player's current total.

### 2. Jokers

This is the primary engine-building system and is almost entirely missing.

*   **Design Set-Based Jokers:** Create a roster of Jokers with abilities tied to the attributes of Set cards (color, shape, number, shading) and Set-specific scoring (uniform/ladder features), rather than poker ranks and suits.
*   **Implement Joker System (Backend):**
    *   In `balatro-server.py`, define the data structure for Jokers.
    *   Integrate Joker effects into the new, extensible scoring formula.
    *   Add logic for adding/removing/selling Jokers.
*   **Implement Joker UI (Frontend):**
    *   In `balatro.js`, write the logic to fetch and display the player's active Jokers in the `joker-area`.
    *   Ensure Joker cards have tooltips explaining their effects.

### 3. Card Modifications & Consumables

These systems add strategic depth and are currently not implemented.

*   **Implement Card Enhancements, Editions, & Seals (Backend):**
    *   Expand the `Card` model in `balatro-server.py` to include data for these modifications.
    *   Add their effects to the game logic (e.g., a Gold Seal adds money, a Steel Card's multiplier persists).
*   **Implement Consumables (Backend):**
    *   Design and implement Tarot and Spectral cards with effects tailored for the Set game (e.g., "Change a card's color," "Make all cards in hand have the same shape").
*   **Update Card Rendering (Frontend):**
    *   Modify the `renderCard` function in `balatro.js` to visually represent enhancements, editions, and seals on the cards.
*   **Implement Consumable UI (Frontend):**
    *   Create a UI for viewing and using Tarot, Spectral, and other consumable cards.

### 4. The Shop & Economy

The shop is a critical part of the macro loop and is completely absent.

*   **Implement Shop Logic (Backend):**
    *   Create server-side logic to handle the shop phase after a blind is won.
    *   The shop should generate a random, buyable selection of Jokers, Booster Packs (containing consumables), and Vouchers.
    *   Implement the logic for buying, selling, and rerolling the shop's stock.
*   **Build Shop UI (Frontend):**
    *   Populate the `#shop-overlay` in `balatro.html` with the full shop interface.
    *   Write the JavaScript in `balatro.js` to display shop items, handle user interactions (click to buy/sell), and communicate with the server.
*   **Implement Vouchers:** Create the system for Vouchers, which are permanent run upgrades purchased from a dedicated slot in the shop.

### 5. Game Structure (Antes & Boss Blinds)

The game progression is too simple and lacks the challenge from the original concept.

*   **Implement Full Ante Structure:** The server logic should properly transition the player through Small Blind -> Big Blind -> Boss Blind -> Shop -> Next Ante.
*   **Design & Implement Boss Blinds:**
    *   Create a variety of Boss Blind modifiers that specifically challenge Set-based strategies (e.g., "All red cards are debuffed," "Sets must have at least 2 ladder features," "Hand size is reduced to 9").
    *   Implement the server logic to apply the random Boss Blind effect for its specific round.
*   **Display Boss Blind UI (Frontend):** Add a clear, visible element to the game UI that explains the current Boss Blind's rule to the player.



================================================
FILE: docs/summary.md
================================================
# Set Game Mechanics Summary

This document outlines the core mechanics of the Set game, based on the implementation in `server.py` and the available game modes in the `static` directory.

## Core Concepts

### Cards

The game uses a deck of 81 unique cards. Each card has four distinct features or dimensions:

1.  **Color**: Each card is one of three colors.
2.  **Shape**: Each card has one of three shapes.
3.  **Number**: Each card displays one of three numbers of symbols.
4.  **Shading**: Each card has one of three shadings (e.g., solid, striped, open).

Every possible combination of these features is represented by a unique card in the deck (3 x 3 x 3 x 3 = 81 cards).

### A "Set"

A "Set" consists of three cards that satisfy a specific rule for each of their four features:

- For each feature (color, shape, number, shading), the values for that feature across the three cards must be **either all the same or all different**.

For example, if we consider the "color" feature for three cards:
- **All same**: All three cards are red. (Valid)
- **All different**: One card is red, one is green, and one is blue. (Valid)
- **Two same, one different**: Two cards are red and one is blue. (Invalid)

This rule must hold true for all four features for the three cards to be considered a valid Set.

## Game Modes

The application implements several game modes, each with a slightly different objective.

### 1. Classic Mode (`index.html`)

This is the standard way to play the game.
- The game board starts with 12 cards dealt from the deck.
- The player must identify a valid Set from the cards on the board.
- When a Set is found, the three cards are removed and replaced by three new cards from the deck.
- If no Sets are present in the 12 cards on the board, three additional cards can be dealt.

### 2. Timed Mode (`timed.html`)

This mode challenges the player to find as many Sets as possible within a fixed time limit.
- The gameplay is similar to the Classic Mode.
- A timer counts down, and the game ends when the timer reaches zero.
- The player's score is based on the number of Sets found.
- This mode includes a leaderboard to track high scores.

### 3. Infinite Mode (`infinite.html`)

This mode allows for a more relaxed gameplay experience without any time pressure.
- The player can find Sets continuously without a game-ending condition.
- The game continues as long as the player wishes to play.

### 4. Challenge Mode (`challenge.html`)

This mode presents a specific puzzle or challenge to the player.
- The game presents a fixed board of cards.
- The challenge is to find all possible Sets within that specific arrangement of cards.
- This mode tests the player's ability to spot all potential combinations in a static layout.

## API Endpoints

The game's logic is handled by a backend server with the following key API endpoints:

- `POST /api/v1/is_set`: Checks if a provided combination of three cards constitutes a valid Set.
- `POST /api/v1/deal_cards`: Deals a specified number of cards, allowing for a new game or adding cards to the board.
- `POST /api/v1/find_set`: Finds a single valid Set from the cards currently on the board (can be used for hints).
- `POST /api/v1/find_all_sets`: Finds all possible Sets from the cards on the board.
- `GET /api/v1/get_leaderboard`: Retrieves the current high scores for the Timed Mode.
- `POST /api/v1/post_score`: Adds a new score to the leaderboard.



================================================
FILE: static/app.js
================================================
// Error dialog elements
const errorContent = document.querySelector('.error-content');
const errorDialog = document.getElementById('error-dialog');
const errorMessage = document.querySelector('.error-message');
const errorCloseBtn = document.querySelector('.error-close-btn');

errorCloseBtn.addEventListener('click', () => {
    errorDialog.classList.add('hidden');
});


export function showMsg(message, color = 'red') {
    errorMessage.textContent = message;
    errorDialog.classList.remove('hidden');

    errorMessage.style.color = color;
    errorCloseBtn.style.backgroundColor = color;
    
    // change border-left color of errorContent
    errorContent.style.borderLeftColor = color;
}


const backButton = document.getElementById('back-button');
export const gameBoardDiv = document.getElementById('game-board');
export const cardGrid = document.getElementById('card-grid');
export const timerSpan = document.getElementById('timer');
export const scoreSpan = document.getElementById('score');
export const challengeStats = document.getElementById('challenge-stats');
export const setsFoundSpan = document.getElementById('sets-found');
export const setsTotalSpan = document.getElementById('sets-total');
export const gameOverModal = document.getElementById('game-over-modal');
export const finalScoreSpan = document.getElementById('final-score');
export const nameInput = document.getElementById('name-input');
export const leaderboardList = document.getElementById('leaderboard-list');
export const hintButton = document.getElementById('hint-button');
export const challengeSetsContainer = document.getElementById('challenge-sets-container');
export const allSetsList = document.getElementById('all-sets-list');

export let timer;
export let score = 0;
export let timeLeft = 30;
export let dealtCards = [];
export let selectedCards = [];
export let allSets = [];
export let foundSets = [];
export let excludedCardsQueue = [];
export let hintSet = null;
export let seed = null;
export let hintsUsed = 0;
export let foundSetCount = 0;
export let totalHintsUsed = 0;

export function setTimer(newTimer) { timer = newTimer; }
export function setScore(newScore) { score = newScore; }
export function setTimeLeft(newTimeLeft) { timeLeft = newTimeLeft; }
export function addTimeLeft(seconds) { timeLeft += seconds; }
export function removeTimeLeft(seconds) { timeLeft -= seconds; }
export function setDealtCards(newDealtCards) { dealtCards = newDealtCards; }
export function setSelectedCards(newSelectedCards) { selectedCards = newSelectedCards; }
export function setAllSets(newAllSets) { allSets = newAllSets; }
export function setFoundSets(newFoundSets) { foundSets = newFoundSets; }
export function setExcludedCardsQueue(newExcludedCardsQueue) { excludedCardsQueue = newExcludedCardsQueue; }
export function setHintSet(newHintSet) { hintSet = newHintSet; }
export function setSeed(newSeed) { seed = newSeed; }

const colors = ['red', 'purple', 'green'];
const shadings = ['solid', 'striped', 'open'];

export function createCardElement(card, cardIndex = 0) {
    const cardElement = document.createElement('div');
    cardElement.classList.add('card');
    cardElement.dataset.card = JSON.stringify(card);
    
    const color = colors[card.color_val];
    const shading = shadings[card.shading_val];

    const getShapePath = (shape_val) => {
        switch(shape_val) {
            // Oval
            case 0: return `<ellipse cx="50" cy="50" rx="40" ry="25"/>`;
            // Triangle shape
            case 1: return `<polygon points="50,10 90,90 10,90"/>`;
            // Rectangle
            case 2: return `<rect x="2.5" y="30" width="95" height="40"/>`;
            default: return '';
        }
    }
    
    let shapeHTML = getShapePath(card.shape_val);
    let defsHTML = '';
    let fill_attr, stroke_attr, stroke_width_attr;

    if (shading === 'solid') {
        fill_attr = color;
        stroke_attr = 'none';
        stroke_width_attr = '0';
    } else if (shading === 'striped') {
        const patternId = `pattern-${card.color_val}-${card.shading_val}-${card.shape_val}-${card.number_val}-${cardIndex}`;
        defsHTML = `
            <defs>
                <pattern id="${patternId}" patternUnits="userSpaceOnUse" width="6" height="6">
                    <circle cx="2" cy="2" r="1.2" fill="${color}" />
                </pattern>
            </defs>`;
        fill_attr = `url(#${patternId})`;
        stroke_attr = color;
        stroke_width_attr = '4';
    } else { // open
        fill_attr = 'none';
        stroke_attr = color;
        stroke_width_attr = '4.5';
    }

    shapeHTML = shapeHTML.replace('/>', ` fill="${fill_attr}" stroke="${stroke_attr}" stroke-width="${stroke_width_attr}" />`);

    const symbolSvg = `
        <svg viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg" preserveAspectRatio="xMidYMid meet">
            ${defsHTML}
            ${shapeHTML}
        </svg>`;

    const content = [];
    for (let i = 0; i <= card.number_val; i++) {
        content.push(symbolSvg);
    }

    cardElement.classList.add(`count-${content.length}`);
    cardElement.innerHTML = content.join('');
    return cardElement;
}

export function renderCards(gameMode) {
    console.log("Rendering cards...");
    cardGrid.innerHTML = '';
    if (dealtCards.length === 15) {
        cardGrid.classList.add('three-columns');
        cardGrid.classList.remove('four-columns');
    } else if (dealtCards.length > 12) {
        cardGrid.classList.add('four-columns');
        cardGrid.classList.remove('three-columns');
    } else {
        cardGrid.classList.remove('four-columns');
        cardGrid.classList.remove('three-columns');
    }

    dealtCards.forEach((card, cardIndex) => {
        const cardElement = createCardElement(card, cardIndex);
        cardElement.addEventListener('click', () => selectCard(cardElement, gameMode));
        cardGrid.appendChild(cardElement);
    });
}

export function selectCard(cardElement, gameMode) {
    const card = JSON.parse(cardElement.dataset.card);
    const index = selectedCards.findIndex(c => JSON.stringify(c) === JSON.stringify(card));

    if (index > -1) {
        selectedCards.splice(index, 1);
        cardElement.classList.remove('selected');
    } else {
        if (selectedCards.length < 3) {
            selectedCards.push(card);
            cardElement.classList.add('selected');
        }
    }

    if (selectedCards.length === 3) {
        checkSet(gameMode);
    }
}

export async function checkSet(gameMode) {
    console.log("Checking set:", selectedCards);
    const cardsToCheck = [...selectedCards];
    const response = await fetch('/api/v1/is_set', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(cardsToCheck)
    });
    const data = await response.json();

    if (data.ok) {
        console.log("Set is valid.");
        if (gameMode === 'challenge') {
            const sortedSet = cardsToCheck.sort((a, b) => JSON.stringify(a).localeCompare(JSON.stringify(b)));
            const setString = JSON.stringify(sortedSet);
            if (!foundSets.includes(setString)) {
                setFoundSets([...foundSets, setString]);
                setsFoundSpan.textContent = foundSets.length;
                
                const setIndex = allSets.findIndex(s => s === setString);
                if (setIndex > -1) {
                    const setItem = document.getElementById(`set-item-${setIndex}`);
                    setItem.classList.add('found');
                    setItem.innerHTML = ''; // Clear placeholder
                    sortedSet.forEach((card, cardIndex) => {
                        const cardElement = createCardElement(card, `set-${setIndex}-${cardIndex}`);
                        setItem.appendChild(cardElement);
                    });
                }

                if (foundSets.length === allSets.length) {
                    setTimeout(() => endGame(gameMode), 500);
                }
            }
        } else {
            if (gameMode === 'timed') {
                timerSpan.textContent = timeLeft;
                switch (hintsUsed) {
                     case 0:
                        score++;
                        addTimeLeft(10);
                        break;
                    case 1:
                        score += 0.5;
                        addTimeLeft(5);
                        break;
                    case 2:
                        score += 0.25;
                        addTimeLeft(2);
                        break;
                }
                totalHintsUsed += hintsUsed;
                hintsUsed = 0;
                foundSetCount++;
            } else {
                score++;
            }
            scoreSpan.textContent = score;
        }
        await replaceCards(cardsToCheck, gameMode);
    } else {
        console.error("Set is invalid:", data.message);
        showMsg(data.message);
    }
    setSelectedCards([]);
    document.querySelectorAll('.card.selected').forEach(c => c.classList.remove('selected'));
}

export async function findAndStoreHint(gameMode) {
    console.log("Finding and storing hint...");
    const response = await fetch('/api/v1/find_set', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(dealtCards)
    });
    const data = await response.json();
    if (data.ok) {
        setHintSet(data.set);
    } else {
        setHintSet(null);
        if (dealtCards.length < 15) {
            await dealExtraCards(gameMode);
        } else {
            showMsg("No set found in 15 cards. Dealing a new game.");
            await dealInitialCards(gameMode, seed + "" + Math.floor(Math.random() * 1000));
        }
    }
}

export async function dealExtraCards(gameMode) {
    console.log("Dealing extra cards...");
    const excludeList = [...dealtCards];
    const response = await fetch('/api/v1/deal_cards', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ n_cards: 3, seed: seed ? parseInt(seed) : null, exclude: excludeList })
    });
    const data = await response.json();
    if (data.ok) {
        setDealtCards([...dealtCards, ...data.cards]);
        renderCards(gameMode);
        await findAndStoreHint(gameMode);
    } else {
        console.error("Failed to deal extra cards:", data.message);
    }
}

export function getHint(gameMode) {
    if (hintSet) {
        console.log("Using stored hint:", hintSet);
        let cardToHint = hintSet[Math.floor(Math.random() * hintSet.length)];
        if( gameMode === 'timed') {
            cardToHint = hintSet[hintsUsed % hintSet.length];
            hintsUsed++;
        }
        document.querySelectorAll('.card').forEach(cardElement => {
            const card = JSON.parse(cardElement.dataset.card);
            if (JSON.stringify(card) === JSON.stringify(cardToHint)) {
                cardElement.classList.add('hint');
            }
        });
        setTimeout(() => {
            document.querySelectorAll('.card.hint').forEach(c => c.classList.remove('hint'));
        }, 2000);
    } else if (gameMode === 'challenge') {
        showMsg("Hint not available in challenge mode.");
    } else {
        showMsg("No set found to hint.");
    }
}

export async function fetchAllSets() {
    console.log("Fetching all sets...");
    const response = await fetch('/api/v1/find_all_sets', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(dealtCards)
    });
    const data = await response.json();
    if (data.ok) {
        setAllSets(data.sets.map(s => JSON.stringify(s.sort((a, b) => JSON.stringify(a).localeCompare(JSON.stringify(b))))));
        setsTotalSpan.textContent = allSets.length;
        setsFoundSpan.textContent = 0;
        allSetsList.innerHTML = '';
        allSets.forEach((set, index) => {
            const setItem = document.createElement('div');
            setItem.classList.add('set-item');
            setItem.id = `set-item-${index}`;
            for (let i = 0; i < 3; i++) {
                const hiddenCard = document.createElement('div');
                hiddenCard.classList.add('card', 'hidden-card');
                setItem.appendChild(hiddenCard);
            }
            allSetsList.appendChild(setItem);
        });
    } else {
        console.error("Failed to fetch all sets:", data.message);
    }
}

export async function replaceCards(cardsToReplace, gameMode) {
    console.log("Replacing cards...");

    if (gameMode === 'challenge') {
        // In challenge mode, cards are not replaced
        document.querySelectorAll('.card.selected').forEach(c => c.classList.remove('selected'));
        setSelectedCards([]);
        return;
    }

    if (dealtCards.length > 12) {
        setDealtCards(dealtCards.filter(card => !cardsToReplace.find(c => JSON.stringify(c) === JSON.stringify(card))));
        renderCards(gameMode);
        await findAndStoreHint(gameMode);
        return;
    }

    if (gameMode === 'infinite') {
        let newExcludedCardsQueue = [...excludedCardsQueue];
        newExcludedCardsQueue.forEach(item => item.setsPassed++);
        newExcludedCardsQueue.push({ cards: cardsToReplace, setsPassed: 0 });
        setExcludedCardsQueue(newExcludedCardsQueue.filter(item => item.setsPassed < 2));
    }

    let excludeList = [...dealtCards];
    if (gameMode === 'infinite') {
        const recentlyUsed = excludedCardsQueue.flatMap(item => item.cards);
        excludeList = [...dealtCards, ...recentlyUsed];
    }

    const response = await fetch('/api/v1/deal_cards', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ n_cards: 3, seed: seed ? parseInt(seed) : null, exclude: excludeList })
    });
    const data = await response.json();
    if (data.ok) {
        console.log("New cards received:", data.cards);
        const newCards = data.cards;
        let newCardIndex = 0;
        let newDealtCards = dealtCards.map(card => {
            if (cardsToReplace.find(c => JSON.stringify(c) === JSON.stringify(card))) {
                if (newCardIndex < newCards.length) {
                    return newCards[newCardIndex++];
                }
                return null;
            }
            return card;
        }).filter(card => card !== null);
        while (newCardIndex < newCards.length) {
            newDealtCards.push(newCards[newCardIndex++]);
        }
        setDealtCards(newDealtCards);
        renderCards(gameMode);
        await findAndStoreHint();
    } else {
        console.error("Failed to replace cards:", data.message);
    }
}

export function endGame(gameMode) {
    if (gameMode === 'timed') {
        gameOverModal.classList.remove('hidden');
        score = Math.floor(score);
        finalScoreSpan.textContent = `Time's up! You found ${foundSetCount} sets with the help of ${totalHintsUsed} hints!\nYour final score is: ${score}`;
        fetchLeaderboard();
    } else {
        window.location.href = "/";
    }
}

export async function fetchLeaderboard() {
    const response = await fetch('/api/v1/get_leaderboard');
    const leaderboard = await response.json();
    leaderboardList.innerHTML = '';
    leaderboard.forEach(entry => {
        const li = document.createElement('li');
        li.textContent = `${entry.name}: ${entry.score}`;
        leaderboardList.appendChild(li);
    });
}

export async function submitScore() {
    const name = nameInput.value;
    if (!name) {
        showMsg('Please enter your name.');
        return;
    }
    await fetch('/api/v1/post_score', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ name, score })
    });
    gameOverModal.classList.add('hidden');
    window.location.href = '/';
}

export async function dealInitialCards(gameMode, overrideSeed = false) {
    console.log("Dealing initial cards with seed:", seed);

    if (!seed) {
        setSeed(Math.floor(Math.random() * 1000000).toString()); // Generate
        console.log("No seed provided, generating random seed:", seed);
    }
    if (overrideSeed) {
        setSeed(overrideSeed);
    }
    
    if (gameMode === 'challenge') {
        let hasSet = false;
        let nTries = 0;
        while (!hasSet) {
            nTries++;
            if (nTries !== 1) {
                setSeed(seed + "" + nTries); // Append try number to seed for uniqueness
            }
            const response = await fetch('/api/v1/deal_cards', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ n_cards: 12, seed: seed})
            });
            const data = await response.json();
            if (data.ok) {
                console.log("Initial cards received:", data.cards);
                setDealtCards(data.cards);
                
                const setResponse = await fetch('/api/v1/find_set', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(dealtCards)
                });
                const setData = await setResponse.json();
                hasSet = setData.ok;
                
                if (!hasSet) {
                    console.log("No set found in initial cards, dealing new set...");
                    setSeed(Math.floor(Math.random() * 1000000).toString());
                }
            } else {
                console.error("Failed to deal initial cards:", data.message);
                return;
            }
        }
    } else {
        const response = await fetch('/api/v1/deal_cards', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ n_cards: 12, seed: seed})
        });
        const data = await response.json();
        if (data.ok) {
            console.log("Initial cards received:", data.cards);
            setDealtCards(data.cards);
        } else {
            console.error("Failed to deal initial cards:", data.message);
            return;
        }
    }

    renderCards(gameMode);
    if (gameMode === 'challenge') {
        await fetchAllSets();
    } else {
        await findAndStoreHint(gameMode);
    }
}

document.addEventListener('DOMContentLoaded', () => {
    backButton.addEventListener('click', () => {
        window.location.href = '/';
    });
});



================================================
FILE: static/balatro-style.css
================================================
@import url('https://fonts.googleapis.com/css2?family=VT323&family=Press+Start+2P&display=swap');

:root {
    --card-width: 100px;
    --card-height: 150px;
    --card-border-radius: 0;
    --card-bg-color: linear-gradient(145deg, #ffffff, #f0f0f0);
    --card-border-color: #000;
    --card-selected-color: #4a90e2;
    --joker-common: #000;
    --joker-uncommon: #4caf50;
    --joker-rare: #2196f3;
    --joker-legendary: #ff9800;
}

body {
    font-family: 'VT323', monospace;
    background-color: #d4d4d4;
    background-image: url("data:image/svg+xml,%3Csvg width='6' height='6' viewBox='0 0 6' xmlns='http://www.w3.org/2000/svg'%3E%3Cg fill='%239C92AC' fill-opacity='0.2' fill-rule='evenodd'%3E%3Cpath d='M5 0h1L0 6V5zM6 5v1H5z'/%3E%3C/g%3E%3C/svg%3E");
    color: #1a1a1a;
    display: flex;
    justify-content: center;
    align-items: flex-start;
    padding-top: 20px;
    min-height: 100vh;
    margin: 0;
    font-size: 1.2em;
}

#back-button-container {
    position: absolute;
    top: 10px;
    left: 10px;
}

#back-button {
    font-family: 'Press Start 2P', cursive;
    padding: 10px 15px;
    font-size: 0.7em;
    border: 3px solid #000;
    background: linear-gradient(145deg, #fefefe, #e8e8e8);
    box-shadow: 4px 4px 0 #000;
    cursor: pointer;
    color: #000;
    text-transform: uppercase;
}

#back-button:hover {
    transform: translate(2px, 2px);
    box-shadow: 2px 2px 0 #000;
}

#back-button:active {
    transform: translate(4px, 4px);
    box-shadow: none;
}

#game-container {
    display: flex;
    flex-direction: column;
    gap: 15px;
    width: 90%;
    max-width: 1200px;
    background: #e8e8e8;
    padding: 30px;
    border: 3px solid #000;
    box-shadow: 8px 8px 0 #000;
    position: relative; /* For popups */
}

#game-info {
    display: flex;
    justify-content: space-between;
    align-items: center;
    background: #fff;
    padding: 15px;
    border: 2px solid #000;
    box-shadow: inset 2px 2px 5px rgba(0,0,0,0.2);
}

#money, #ante-info {
    font-family: 'Press Start 2P', cursive;
    font-size: 0.8em;
    text-shadow: 2px 2px #e8e8e8;
}

#blind-info {
    text-align: right;
    font-family: 'Press Start 2P', cursive;
    font-size: 0.8em;
    text-shadow: 2px 2px #e8e8e8;
}

#blind-type {
    font-size: 1.2em;
    display: block;
}

#score-progress-container {
    background-color: #fff;
    border: 2px solid #000;
    padding: 2px;
    margin-top: 5px;
    width: 250px; /* Fixed width */
    position: relative;
    height: 24px;
    display: flex;
    align-items: center;
    justify-content: center;
    box-shadow: inset 1px 1px 3px rgba(0,0,0,0.2);
}

#score-progress-bar {
    background-color: #4a90e2;
    height: 100%;
    width: 0%; /* Will be set by JS */
    position: absolute;
    top: 0;
    left: 0;
    transition: width 0.5s ease-in-out;
}

#score-progress-container span {
    position: relative;
    z-index: 1;
    color: #1a1a1a;
    text-shadow: 1px 1px 0px #fff;
}

#boss-blind-effect-display {
    background-color: #dc3545;
    color: #fff;
    text-shadow: 1px 1px #000;
    padding: 5px 8px;
    border: 2px solid #000;
    margin-top: 5px;
    font-size: 0.9em;
}
.effect-title {
    font-weight: bold;
}

#joker-area, #consumable-area {
    display: flex;
    gap: 10px;
    padding: 15px;
    background: #fff;
    border: 2px solid #000;
    box-shadow: inset 2px 2px 5px rgba(0,0,0,0.2);
    min-height: 120px;
    align-items: center;
    flex-wrap: wrap;
}

.joker-card, .consumable-card {
    width: 120px;
    height: 185px;
    border: 3px solid #000;
    padding: 0;
    display: flex;
    flex-direction: column;
    align-items: center;
    text-align: center;
    background: linear-gradient(145deg, #ffffff, #f0f0f0);
    box-shadow: 3px 3px 0 #000;
    position: relative;
    color: #1a1a1a;
    justify-content: center;
    transition: transform 0.2s ease-out, box-shadow 0.2s ease-out, opacity 0.2s ease-out;
}

.joker-card[draggable="true"] {
    cursor: grab;
}

.joker-card.dragging {
    opacity: 0.4;
    transform: scale(1.05);
    box-shadow: 8px 8px 10px rgba(0,0,0,0.3);
    cursor: grabbing;
}

.consumable-card {
    cursor: pointer;
}

.consumable-card:hover {
    transform: translateY(-2px);
    box-shadow: 5px 5px 0 #000;
}

.card-image-container {
    width: 100%;
    height: 100%;
    background-color: #ddd;
    border: none;
    display: flex;
    align-items: center;
    justify-content: center;
    overflow: hidden;
}

.card-image {
    width: 100%;
    height: 100%;
    object-fit: cover;
}

.joker-card.common, .consumable-card.common { border-color: var(--joker-common); }
.joker-card.uncommon, .consumable-card.uncommon { border-color: var(--joker-uncommon); }
.joker-card.rare, .consumable-card.rare { border-color: var(--joker-rare); }
.joker-card.legendary, .consumable-card.legendary { border-color: var(--joker-legendary); }

/* Rarity colors are applied to border */

.joker-badge {
    position: absolute;
    top: -10px;
    right: -10px;
    background-color: #ffc107;
    color: #212529;
    border: 2px solid #000;
    display: flex;
    align-items: center;
    justify-content: center;
    font-weight: bold;
    font-size: 0.8em;
    box-shadow: 2px 2px 0 #000;
}

#board-area {
    padding: 20px;
    background: #fff;
    border: 2px solid #000;
    box-shadow: inset 3px 3px 6px rgba(0,0,0,0.2);
}

#card-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(var(--card-width), 1fr));
    gap: 15px;
    justify-content: center;
}

.card {
    width: var(--card-width);
    height: var(--card-height);
    border: 3px solid var(--card-border-color);
    border-radius: var(--card-border-radius);
    background: var(--card-bg-color);
    cursor: pointer;
    transition: all 0.2s ease-in-out;
    display: flex;
    justify-content: center;
    align-items: center;
    position: relative;
    overflow: hidden;
    box-shadow: 5px 5px 0 #000;
}

.card:hover {
    transform: translateY(-5px);
    box-shadow: 7px 7px 0 #000;
}

.card.selected {
    border-color: var(--card-selected-color);
    background: linear-gradient(145deg, #4a90e2, #357abd);
    box-shadow: 5px 5px 0 #1a1a1a;
    transform: scale(1.05);
}

.card.shake {
    animation: shake 0.5s;
}

@keyframes shake {
  10%, 90% { transform: translate3d(-1px, 0, 0); }
  20%, 80% { transform: translate3d(2px, 0, 0); }
  30%, 50%, 70% { transform: translate3d(-4px, 0, 0); }
  40%, 60% { transform: translate3d(4px, 0, 0); }
}

.card.deal-in {
    animation: dealIn 0.5s ease-out forwards;
    opacity: 0;
    transform: translateY(50px);
}

@keyframes dealIn {
    to {
        opacity: 1;
        transform: translateY(0);
    }
}

.card.fly-out {
    /* This class is used as a marker in JS, the animation is handled via style properties */
    z-index: 100;
}

/* Card Enhancements */
.enhancement-overlay {
    position: absolute;
    top: 5px;
    left: 5px;
    color: white;
    padding: 2px 5px;
    border-radius: 3px;
    font-size: 0.8em;
    font-weight: bold;
    text-shadow: 1px 1px 2px black;
}

.enhancement-bonus {
    background-color: rgba(20, 120, 220, 0.9); /* Blue for chips */
    border: 1px solid #6dcff6;
}

.enhancement-mult {
    background-color: rgba(220, 50, 50, 0.9); /* Red for mult */
    border: 1px solid #f08080;
}

.enhancement-xmult {
    background-color: rgba(138, 43, 226, 0.9); /* Purple for xmult */
    border: 1px solid #c382f0;
}

.enhancement-gold {
    background-color: rgba(255, 215, 0, 0.9); /* Gold for money */
    border: 1px solid rgb(255, 215, 0);
    color: black;
    text-shadow: 1px 1px 2px white;
}

.gold-card-background {
    background: linear-gradient(145deg, #fff2a8, #e6c74e);
}

.enhancement-wild {
    background-color: rgba(128, 0, 128, 0.9); /* Purple for wild */
    border: 1px solid #da70d6;
    color: white;
    text-shadow: 1px 1px 2px black;
}

.wild-card-background {
    background: repeating-radial-gradient(
        circle,
        #e6e6fa,
        #e6e6fa 10px,
        #d8bfd8 10px,
        #d8bfd8 20px
    );
}

.shape {
    stroke: black;
    stroke-width: 2;
}

#controls {
    display: flex;
    justify-content: center;
    align-items: center;
    gap: 20px;
    padding: 10px;
}

#controls button {
    font-family: 'Press Start 2P', cursive;
    padding: 12px 24px;
    font-size: 0.8em;
    border: 3px solid #000;
    background: linear-gradient(145deg, #fefefe, #e8e8e8);
    box-shadow: 5px 5px 0 #000;
    cursor: pointer;
    transition: all 0.1s ease;
    color: #000;
    text-transform: uppercase;
    position: relative;
}

#controls button:disabled {
    background: #aaa;
    box-shadow: 5px 5px 0 #555;
    cursor: not-allowed;
    color: #777;
}

#controls button:not(:disabled):hover {
    transform: translate(2px, 2px);
    box-shadow: 3px 3px 0 #000;
}

#controls button:active:not(:disabled) {
    transform: translate(5px, 5px);
    box-shadow: none;
}

#play-set-button:not(:disabled) {
    background: linear-gradient(145deg, #32cd32, #228b22);
    color: white;
    text-shadow: 2px 2px #000;
}

#discard-button:not(:disabled) {
    background: linear-gradient(145deg, #dc3545, #c82333);
    color: white;
    text-shadow: 2px 2px #000;
}

.board-info {
    font-family: 'Press Start 2P', cursive;
    font-size: 0.9em;
    background-color: #fff;
    padding: 10px 15px;
    border: 2px solid #000;
    box-shadow: inset 1px 1px 3px rgba(0,0,0,0.2);
}

#end-run-container, #lobby-controls {
    text-align: center;
    padding: 20px;
}

#lobby-new-run-button, #return-to-lobby-button {
    font-family: 'Press Start 2P', cursive;
    padding: 15px 30px;
    font-size: 1.2em;
    border: 3px solid #000;
    background: linear-gradient(145deg, #32cd32, #228b22);
    box-shadow: 5px 5px 0 #000;
    cursor: pointer;
    color: white;
    text-shadow: 2px 2px #000;
    text-transform: uppercase;
}

#return-to-lobby-button {
    background: linear-gradient(145deg, #fefefe, #e8e8e8);
    color: #000;
    text-shadow: none;
}

/* Modal styles */
.modal {
    display: none; /* Hidden by default */
    position: fixed; /* Stay in place */
    z-index: 1000; /* Sit on top */
    left: 0;
    top: 0;
    width: 100%; /* Full width */
    height: 100%; /* Full height */
    overflow: auto; /* Enable scroll if needed */
    background-color: rgba(0,0,0,0.6); /* Black w/ opacity */
}

.modal-content {
    background: #e8e8e8;
    margin: 15% auto;
    padding: 30px;
    border: 3px solid #000;
    box-shadow: 8px 8px 0 #000;
    width: 80%;
    max-width: 500px;
    text-align: center;
    position: relative;
}

.close-btn {
    color: #1a1a1a;
    position: absolute;
    top: 10px;
    right: 20px;
    font-size: 40px;
    font-weight: bold;
    cursor: pointer;
    font-family: Arial, sans-serif;
}

.close-btn:hover,
.close-btn:focus {
    color: #dc3545;
}

.error-message {
    color: #dc3545;
    font-size: 1em;
    margin: 15px 0 25px;
    font-family: 'Press Start 2P', cursive;
    text-shadow: 2px 2px #000;
}

.error-close-btn {
    font-family: 'Press Start 2P', cursive;
    padding: 10px 20px;
    font-size: 0.8em;
    border: 3px solid #000;
    background: linear-gradient(145deg, #fefefe, #e8e8e8);
    box-shadow: 5px 5px 0 #000;
    cursor: pointer;
    color: #000;
    text-transform: uppercase;
    margin-top: 15px;
}

#error-dialog.hidden {
    display: none;
}

/* Shop Area */
#shop-area {
    padding: 20px;
    background: #fff;
    border: 2px solid #000;
    box-shadow: inset 3px 3px 6px rgba(0,0,0,0.2);
    text-align: center;
    display: grid;
    grid-template-columns: auto auto auto auto auto auto;
    grid-template-rows: auto auto auto;
}

#shop-area.hidden {
    display: none;
}

#shop-area h2 {
    font-family: 'Press Start 2P', cursive;
    font-size: 1.5em;
    color: #000;
    text-shadow: 3px 3px #e8e8e8;
    margin-top: 0;
    margin-bottom: 20px;
}

#shop-buttons {
    display: flex;
    justify-content: center;
    gap: 20px;
    margin-bottom: 20px;
    grid-column: 1 / span 2;
    grid-row: 2;
    flex-direction: column;
    align-items: center;
}

#shop-buttons button {
    font-family: 'Press Start 2P', cursive;
    width: 60%;
    aspect-ratio: 5 / 3;
    padding: 12px 24px;
    font-size: 1em;
    border: 3px solid #000;
    box-shadow: 5px 5px 0 #000;
    cursor: pointer;
    color: #000;
    text-transform: uppercase;
}

#close-shop-button {
    background: linear-gradient(145deg, #4caf50, #388e3c);
}

#reroll-button {
    background: linear-gradient(145deg, #ff9800, #f57c00);
}

#reroll-button p {
    margin: 0;
    font-size: 0.75em;
    color: #000;
    text-shadow: 1px 1px #000;
}

#card-items {
    display: flex;
    justify-content: center;
    gap: 20px;
    margin: 30px 0;
    padding: 20px 0;
    flex-wrap: wrap;
    grid-column: 3 / span 4; /* Center cards in the grid */
    grid-row: 2;
    background-color: whitesmoke;
    border-radius: 5px;
}

#voucher-items {
    display: flex;
    justify-content: center;
    gap: 20px;
    margin: 30px 0;
    flex-wrap: wrap;
    grid-column: 1 / span 3; /* Center vouchers in the grid */
    grid-row: 3;
}

#pack-items {
    display: flex;
    justify-content: center;
    gap: 20px;
    margin: 30px 0;
    flex-wrap: wrap;
    grid-column: 4 / span 3; /* Center packs in the grid */
    grid-row: 3;
}

#shop-txt{
    grid-row: 1;
    grid-column: 1 / span 6;
}

.shop-item {
    background: #fff;
    border: 2px solid #000;
    box-shadow: inset 2px 2px 5px rgba(0,0,0,0.2);
    padding: 15px;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 10px;
    min-width: 150px;
}

.shop-item .joker-card {
    width: 120px;
    height: 185px;
}

.shop-item button {
    font-family: 'Press Start 2P', cursive;
    padding: 8px 16px;
    font-size: 0.7em;
    border: 3px solid #000;
    background: linear-gradient(145deg, #32cd32, #228b22);
    box-shadow: 4px 4px 0 #000;
    cursor: pointer;
    color: white;
    text-shadow: 1px 1px #000;
    text-transform: uppercase;
}

.shop-item button:disabled {
    background: #aaa;
    box-shadow: 4px 4px 0 #555;
    cursor: not-allowed;
    color: #777;
}

.shop-item button:hover:not(:disabled) {
    transform: translate(2px, 2px);
    box-shadow: 2px 2px 0 #000;
}

.shop-item .booster-pack-item {
    justify-content: center;
    background: linear-gradient(45deg, #6a11cb, #2575fc);
    height: 185px;
    width: 120px;
}

.shop-item .booster-pack-item .name {
    font-size: 1.2em;
    font-weight: bold;
}

#scoring-display {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: #e8e8e8;
    color: #1a1a1a;
    padding: 30px;
    border: 3px solid #000;
    box-shadow: 8px 8px 0 #000;
    z-index: 100;
    width: 90%;
    max-width: 450px;
    text-align: center;
    opacity: 0;
    transition: opacity 0.3s ease-in-out, transform 0.3s ease-in-out;
    transform-origin: center;
    display: flex;
    flex-direction: column;
    gap: 15px;
}

#scoring-display.show {
    opacity: 1;
    transform: translate(-50%, -50%) scale(1);
}

#scoring-display.hide {
    opacity: 0;
    transform: translate(-50%, -50%) scale(0.9);
}

.scoring-calculation {
    background-color: #fff;
    padding: 10px;
    border: 2px solid #000;
    box-shadow: inset 1px 1px 3px rgba(0,0,0,0.2);
}

.scoring-total {
    font-family: 'Press Start 2P', cursive;
    font-size: 1.8em;
    color: #4a90e2;
    text-shadow: 2px 2px #e8e8e8;
}

.scoring-x {
    font-size: 0.8em;
    color: #1a1a1a;
    margin: 0 10px;
}

#scoring-log-area {
    height: 200px;
    overflow-y: auto;
    display: flex;
    flex-direction: column-reverse;
    background-color: #fff;
    border: 2px solid #000;
    box-shadow: inset 2px 2px 5px rgba(0,0,0,0.2);
    padding: 10px;
}

.scoring-log-entry {
    display: flex;
    justify-content: space-between;
    padding: 8px 5px;
    border-bottom: 2px dotted #ccc;
    animation: slideInUp 0.5s ease-out forwards;
    opacity: 0;
}

.scoring-log-entry:last-child {
    border-bottom: none;
}

.scoring-log-entry .source-name {
    font-weight: bold;
}

.scoring-log-entry .source-name.joker {
    color: #9c27b0; /* Purple */
}
.scoring-log-entry .source-name.card {
    color: #4caf50; /* Green */
}
.scoring-log-entry .source-name.set {
    color: #2196f3; /* Blue */
}

.scoring-log-entry .description {
    color: #333;
}

.final-score-gained {
    margin-top: 15px;
    font-size: 1.5em;
    font-family: 'Press Start 2P', cursive;
    color: #228b22;
    text-shadow: 2px 2px #e8e8e8;
    opacity: 0;
    transition: opacity 0.5s ease-in;
}

.final-score-gained.show-final {
    opacity: 1;
}

.joker-card.highlight {
    border-color: #ffd700;
    background: linear-gradient(145deg, #ffd700, #ffa500);
    box-shadow: 5px 5px 0 #1a1a1a;
    transform: scale(1.05);
    transition: transform 0.2s ease-out, box-shadow 0.2s ease-out;
}

.joker-card.card-trigger-highlight {
    border-color: #ff6b6b;
    background: linear-gradient(145deg, #ff6b6b, #e55656);
    box-shadow: 5px 5px 0 #1a1a1a;
    transform: scale(1.1);
    transition: transform 0.2s ease-out, box-shadow 0.2s ease-out;
    animation: cardTriggerPulse 0.7s ease-in-out;
}

@keyframes cardTriggerPulse {
    0%, 100% { 
        box-shadow: 5px 5px 0 #1a1a1a; 
    }
    50% { 
        box-shadow: 5px 5px 0 #1a1a1a, 0 0 20px #ff6b6b; 
    }
}

.scoring-log-entry .source-name.card-trigger {
    color: #ff6b6b;
    font-weight: bold;
    text-shadow: 1px 1px 0 #000;
}

.score-popup {
    position: absolute;
    padding: 10px 15px;
    border-radius: 5px;
    background: rgba(255, 255, 255, 0.9);
    box-shadow: 3px 3px 0 #000;
    font-family: 'Press Start 2P', cursive;
    font-size: 0.8em;
    z-index: 1000; /* Above all other elements */
    animation: slideInUp 0.5s ease-out forwards;
}

.score-popup.card-trigger {
    color: #ff6b6b;
    text-shadow: 2px 2px 0 #000;
    border: 2px solid #ff6b6b;
}

.score-popup.xmult {
    color: #9c27b0;
    font-weight: bold;
    text-shadow: 2px 2px 0 #000;
    border: 2px solid #9c27b0;
}

@keyframes slideInUp {
    from {
        transform: translateY(20px);
        opacity: 0;
    }
    to {
        transform: translateY(0);
        opacity: 1;
    }
}

/* Targeting Overlay */
#targeting-overlay {
    position: absolute;
    bottom: 0;
    left: 0;
    right: 0;
    background: rgba(0, 0, 0, 0.8);
    color: white;
    padding: 15px;
    display: flex;
    justify-content: center;
    align-items: center;
    gap: 20px;
    z-index: 200; /* Above hand, below modals */
}

#targeting-overlay.hidden {
    display: none;
}

#targeting-text {
    font-size: 1.2em;
    text-shadow: 2px 2px #000;
}

#cancel-targeting-button {
    font-family: 'Press Start 2P', cursive;
    padding: 8px 16px;
    font-size: 0.7em;
    border: 3px solid #000;
    background: linear-gradient(145deg, #dc3545, #c82333);
    box-shadow: 4px 4px 0 #000;
    cursor: pointer;
    color: white;
    text-shadow: 1px 1px #000;
    text-transform: uppercase;
}

.card.targetable:hover {
    border-color: #ffc107; /* Gold */
    box-shadow: 7px 7px 0 #ffc107;
    transform: translateY(-5px) scale(1.05);
}

/* Pack Opening Area */
#pack-opening-area {
    padding: 20px;
    background: #fff;
    border: 2px solid #000;
    box-shadow: inset 3px 3px 6px rgba(0,0,0,0.2);
    text-align: center;
}

#pack-opening-area.hidden {
    display: none;
}

#pack-opening-area h2 {
    font-family: 'Press Start 2P', cursive;
    font-size: 1.5em;
    color: #000;
    text-shadow: 3px 3px #e8e8e8;
    margin-top: 0;
    margin-bottom: 20px;
}

#pack-opening-rarity {
    font-family: 'Press Start 2P', cursive;
    font-size: 1.2em;
    margin-bottom: 10px;
    text-transform: capitalize;
}

#pack-opening-rarity.Common { color: var(--joker-common); text-shadow: 1px 1px #fff; }
#pack-opening-rarity.Uncommon { color: var(--joker-uncommon); text-shadow: 1px 1px #000; }
#pack-opening-rarity.Rare { color: var(--joker-rare); text-shadow: 1px 1px #000; }
#pack-opening-rarity.Legendary { color: var(--joker-legendary); text-shadow: 1px 1px #000; }

#pack-opening-instruction {
    font-size: 1.1em;
    margin-bottom: 20px;
}

#pack-opening-choices {
    display: flex;
    justify-content: center;
    gap: 20px;
    margin: 30px 0;
    flex-wrap: wrap;
}

.pack-choice {
    cursor: pointer;
    transition: all 0.2s ease;
}

.pack-choice:hover {
    transform: translateY(-5px) scale(1.02);
}

.pack-choice.selected {
    border-color: var(--card-selected-color);
    transform: scale(1.05);
    box-shadow: 0 0 15px var(--card-selected-color);
}

#confirm-pack-choice-button {
    font-family: 'Press Start 2P', cursive;
    padding: 12px 24px;
    font-size: 1em;
    border: 3px solid #000;
    background: linear-gradient(145deg, #32cd32, #228b22);
    box-shadow: 5px 5px 0 #000;
    cursor: pointer;
    color: white;
    text-shadow: 2px 2px #000;
    text-transform: uppercase;
    margin-top: 20px;
}

#confirm-pack-choice-button:disabled {
    background: #aaa;
    box-shadow: 5px 5px 0 #555;
    cursor: not-allowed;
    color: #777;
    text-shadow: none;
}

/* Scoring animation enhancements */
.scoring-log-entry.card-triggered {
    background: rgba(255, 193, 7, 0.2);
    border-left: 4px solid #ffc107;
    padding-left: 12px;
}

.scoring-log-entry.end-triggered {
    background: rgba(76, 175, 80, 0.2);
    border-left: 4px solid #4caf50;
    padding-left: 12px;
}

.card-trigger-highlight {
    background: linear-gradient(45deg, #ffc107, #ff9800) !important;
    animation: cardTriggerPulse 0.7s ease-in-out;
    box-shadow: 0 0 20px rgba(255, 193, 7, 0.8) !important;
}

.highlight {
    background: linear-gradient(45deg, #4caf50, #2196f3) !important;
    animation: endTriggerPulse 0.7s ease-in-out;
    box-shadow: 0 0 20px rgba(76, 175, 80, 0.8) !important;
}

@keyframes cardTriggerPulse {
    0%, 100% { transform: scale(1); }
    50% { transform: scale(1.1); }
}

@keyframes endTriggerPulse {
    0%, 100% { transform: scale(1); }
    50% { transform: scale(1.05); }
}

.score-popup.card-trigger {
    color: #ff9800 !important;
    text-shadow: 2px 2px 0 #fff, -1px -1px 0 #333;
    font-weight: bold;
    animation: cardTriggerPopup 1.4s ease-out forwards;
}

@keyframes cardTriggerPopup {
    0% {
        opacity: 0;
        transform: translateY(0) scale(0.8);
    }
    20% {
        opacity: 1;
        transform: translateY(-30px) scale(1.2);
    }
    100% {
        opacity: 0;
        transform: translateY(-80px) scale(0.9);
    }
}

#tooltip {
    position: fixed;
    background-color: rgba(0, 0, 0, 0.85);
    color: white;
    padding: 10px 15px;
    border-radius: 5px;
    border: 2px solid #fff;
    font-family: 'VT323', monospace;
    font-size: 1.1em;
    z-index: 2000; /* Ensure it's on top of everything */
    pointer-events: none; /* So it doesn't interfere with mouse events on other elements */
    white-space: pre-wrap; /* To respect newlines in the description */
    max-width: 250px;
    box-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
    text-shadow: 1px 1px 2px #000;
}

#tooltip.hidden {
    display: none;
}

/* Lobby Styles */
#lobby-container {
    width: 90%;
    max-width: 800px;
    background: #e8e8e8;
    padding: 30px;
    border: 3px solid #000;
    box-shadow: 8px 8px 0 #000;
    text-align: center;
}

#lobby-container.hidden {
    display: none;
}

#lobby-container h1 {
    font-family: 'Press Start 2P', cursive;
    font-size: 2em;
    color: #000;
    text-shadow: 3px 3px #e8e8e8;
    margin-bottom: 30px;
}

#saves-list {
    list-style: none;
    padding: 0;
    margin: 0 0 30px 0;
    display: flex;
    flex-direction: column;
    gap: 15px;
}

.save-game-entry {
    background: #fff;
    border: 2px solid #000;
    padding: 20px;
    display: flex;
    justify-content: space-between;
    align-items: center;
    box-shadow: inset 2px 2px 5px rgba(0,0,0,0.2);
}

.save-info {
    display: flex;
    gap: 20px;
    font-size: 1.1em;
    flex-wrap: wrap;
    flex-grow: 1;
    justify-content: space-between;
}

.save-info span {
    min-width: 160px;
    text-align: left;
}

.continue-button, .delete-button {
    font-family: 'Press Start 2P', cursive;
    padding: 10px 20px;
    font-size: 0.8em;
    border: 3px solid #000;
    background: linear-gradient(145deg, #4a90e2, #357abd);
    box-shadow: 4px 4px 0 #000;
    cursor: pointer;
    color: white;
    text-shadow: 1px 1px #000;
    text-transform: uppercase;
    white-space: nowrap;
}

.continue-button:hover, .delete-button:hover {
    transform: translate(2px, 2px);
    box-shadow: 2px 2px 0 #000;
}

.joker-card .sell-joker-button {
    position: absolute;
    bottom: 5px;
    left: 50%;
    transform: translateX(-50%);
    width: 90%;
    padding: 5px;
    font-family: 'Press Start 2P', cursive;
    font-size: 0.6em;
    border: 2px solid #000;
    background: linear-gradient(145deg, #dc3545, #c82333);
    box-shadow: 3px 3px 0 #000;
    color: white;
    text-shadow: 1px 1px #000;
    text-transform: uppercase;
    cursor: pointer;
    opacity: 0;
    visibility: hidden;
    transition: opacity 0.2s, visibility 0.2s;
}

.joker-card:hover .sell-joker-button {
    opacity: 1;
    visibility: visible;
}

.joker-card .sell-joker-button:hover {
    background: linear-gradient(145deg, #e74c3c, #c0392b);
}

.variant-overlay {
    position: absolute;
    top: 42px;
    left: 5px;
    color: white;
    padding: 2px 5px;
    border-radius: 3px;
    font-size: 0.8em;
    font-weight: bold;
    text-shadow: 1px 1px 2px black;
}

.foil {
    background-color: rgba(20, 120, 220, 0.9); /* Blue for chips */
    border: 1px solid #6dcff6;
}

.holographic {
    background-color: rgba(220, 50, 50, 0.9); /* Red for mult */
    border: 1px solid #f08080;
}

.polychrome {
    background-color: rgba(138, 43, 226, 0.9); /* Purple for xmult */
    border: 1px solid #c382f0;
}

.negative {
    background-color: rgb(2, 15, 32, 0.9); 
    border: 1px solid rgb(2, 15, 32);
}



================================================
FILE: static/balatro.html
================================================
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Set - Balatro Mode</title>
    <link rel="stylesheet" href="balatro-style.css">
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <div id="back-button-container">
        <a href="/"><button id="back-button"><-</button></a>
    </div>

    <div id="lobby-container">
        <h1>Balatro Runs</h1>
        <ul id="saves-list">
            <!-- Saved games will be listed here -->
        </ul>
        <div id="lobby-controls">
            <button id="lobby-new-run-button">New Run</button>
        </div>
    </div>

    <div id="game-container" style="display: none;">
        <div id="game-info">
            <div id="money">Money: $<span id="money-value">0</span></div>
            <div id="ante-info">Ante <span id="ante-value">1</span></div>
            <div id="blind-info">
                <span id="blind-type">Small Blind</span>
                <div id="boss-blind-effect-display" class="hidden">
                    <span class="effect-title">Boss Effect:</span>
                    <span id="boss-blind-effect-text"></span>
                </div>
                <div id="score-progress-container">
                    <div id="score-progress-bar"></div>
                    <span id="current-score">0</span> <span>/</span> <span id="required-score">300</span>
                </div>
            </div>
        </div>
        <div id="joker-area">
            <!-- Joker cards will be added here -->
        </div>
        <div id="consumable-area">
            <!-- Consumable cards will be added here -->
        </div>

        <div id="board-area">
            <div id="card-grid">
                <!-- Player's board of cards will be rendered here -->
            </div>
        </div>

        <div id="controls">
            <div class="board-info">
                Boards: <span id="boards-remaining">4</span>
            </div>
            <button id="play-set-button" disabled>Play Set</button>
            <button id="discard-button" disabled>Discard</button>
            <div class="board-info">
                Discards: <span id="discards-remaining">3</span>
            </div>
        </div>
        <div id="controls">
            <p>Order by:</p>
            <button id="order-button-quantity">Quantity</button>
            <button id="order-button-color">Color</button>
            <button id="order-button-shape">Shape</button>
            <button id="order-button-shading">Shading</button>
        </div>
        
        <div id="end-run-container" style="display: none;">
             <button id="return-to-lobby-button">Back to Lobby</button>
        </div>

        <div id="scoring-display" class="hidden">
            <!-- Scoring animation and details will be displayed here -->
        </div>
        
        <div id="shop-area" class="hidden">
            <h2 id="shop-txt">Shop</h2>
            <div id="shop-buttons">
                <button id="close-shop-button">Continue</button>
                <button id="reroll-button">Reroll <p>$5</p> </button>
            </div>
            <div id="card-items">
                <!-- Card items will be rendered here -->
            </div>
            <div id="voucher-items">
                <p>COMING SOON!</p>
                <!-- Voucher items will be rendered here -->
            </div>
            <div id="pack-items">
                <!-- Pack items will be rendered here -->
            </div>
        </div>

        <div id="pack-opening-area" class="hidden">
            <h2 id="pack-opening-title">Opening Pack</h2>
            <p id="pack-opening-rarity"></p>
            <p id="pack-opening-instruction"></p>
            <div id="pack-opening-choices">
                <!-- Choices will be rendered here -->
            </div>
            <button id="confirm-pack-choice-button" disabled>Confirm</button>
        </div>
    </div>

    <div id="targeting-overlay" class="hidden">
        <div id="targeting-content">
            <p id="targeting-text"></p>
            <button id="cancel-targeting-button">Cancel</button>
        </div>
    </div>

    <div id="error-dialog" class="hidden">
        <div class="modal-content error-content">
            <p class="error-message"></p>
            <button class="error-close-btn">OK</button>
        </div>
    </div>

    <div id="tooltip" class="hidden"></div>

    <script src="app.js" type="module"></script>
    <script src="balatro.js" type="module"></script>
</body>
</html>



================================================
FILE: static/balatro.js
================================================
import { showMsg, createCardElement } from './app.js';

const API_BASE = '/api/balatro';

const api = {
    getSaves: () => fetch(`${API_BASE}/saves`).then(res => res.json()),
    newRun: () => fetch(`${API_BASE}/new_run`, { method: 'POST' }).then(res => res.json()),
    getState: (id) => fetch(`${API_BASE}/state?id=${id}`).then(res => res.json()),
    playSet: (id, card_indices) => fetch(`${API_BASE}/play_set?id=${id}`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ card_indices })
    }).then(async res => {
        if (!res.ok) {
            const err = await res.json();
            throw new Error(err.detail || "Server error");
        }
        return res.json();
    }),
    discard: (id, card_indices) => fetch(`${API_BASE}/discard?id=${id}`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ card_indices })
    }).then(res => {
        if (!res.ok) {
            return res.json().then(err => { throw new Error(err.detail || "Server error") });
        }
        return res.json();
    }),
    leaveShop: (id) => fetch(`${API_BASE}/leave_shop?id=${id}`, { method: 'POST' }).then(res => res.json()),
    buyJoker: (id, slot_index) => fetch(`${API_BASE}/buy_joker?id=${id}`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ slot_index })
    }).then(res => {
        if (!res.ok) {
            return res.json().then(err => { throw new Error(err.detail || "Server error") });
        }
        return res.json();
    }),
    buyBoosterPack: (id, slot_index) => fetch(`${API_BASE}/buy_booster_pack?id=${id}`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ slot_index })
    }).then(res => {
        if (!res.ok) {
            return res.json().then(err => { throw new Error(err.detail || "Server error") });
        }
        return res.json();
    }),
    choosePackReward: (id, selected_ids) => fetch(`${API_BASE}/choose_pack_reward?id=${id}`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ selected_ids })
    }).then(res => {
        if (!res.ok) {
            return res.json().then(err => { throw new Error(err.detail || "Server error") });
        }
        return res.json();
    }),
    useConsumable: (id, consumable_index, target_card_indices = []) => fetch(`${API_BASE}/use_consumable?id=${id}`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ consumable_index, target_card_indices })
    }).then(res => {
        if (!res.ok) {
            return res.json().then(err => { throw new Error(err.detail || "Server error") });
        }
        return res.json();
    }),
    reorderJokers: (id, new_order) => fetch(`${API_BASE}/reorder_jokers?id=${id}`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ new_order })
    }).then(res => {
        if (!res.ok) {
            return res.json().then(err => { throw new Error(err.detail || "Server error") });
        }
        return res.json();
    }),
    sellJoker: (id, joker_index) => fetch(`${API_BASE}/sell_joker?id=${id}`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ joker_index })
    }).then(res => {
        if (!res.ok) {
            return res.json().then(err => { throw new Error(err.detail || "Server error") });
        }
        return res.json();
    }),
    deleteSave: (id) => fetch(`${API_BASE}/saves/${id}`, { method: 'DELETE' })
        .then(res => { if (!res.ok) throw new Error("Failed to delete save"); return res.json(); }),
};

let draggedJokerIndex = null;

const state = {
    selectedCards: new Set(),
    selectedPackChoices: new Set(),
    game: null,
    gameId: null,
};

let DOMElements = {};

function init() {
    DOMElements = {
        moneyValue: document.getElementById('money-value'),
        anteValue: document.getElementById('ante-value'),
    blindType: document.getElementById('blind-type'),
    currentScore: document.getElementById('current-score'),
    requiredScore: document.getElementById('required-score'),
    scoreProgressBar: document.getElementById('score-progress-bar'),
    scoreProgressContainer: document.getElementById('score-progress-container'),
    jokerArea: document.getElementById('joker-area'),
    consumableArea: document.getElementById('consumable-area'),
    cardGrid: document.getElementById('card-grid'),
    boardsRemaining: document.getElementById('boards-remaining'),
    discardsRemaining: document.getElementById('discards-remaining'),
    playSetButton: document.getElementById('play-set-button'),
    discardButton: document.getElementById('discard-button'),
    lobbyNewRunButton: document.getElementById('lobby-new-run-button'),
    controls: document.getElementById('controls'),
    boardArea: document.getElementById('board-area'),
    gameContainer: document.getElementById('game-container'),
    lobbyContainer: document.getElementById('lobby-container'),
    savesList: document.getElementById('saves-list'),
    endRunContainer: document.getElementById('end-run-container'),
    returnToLobbyButton: document.getElementById('return-to-lobby-button'),
    scoringDisplay: document.getElementById('scoring-display'),
    shopArea: document.getElementById('shop-area'),
    cardItems: document.getElementById('card-items'),
    packItems: document.getElementById('pack-items'),
    closeShopButton: document.getElementById('close-shop-button'),
    bossBlindEffectDisplay: document.getElementById('boss-blind-effect-display'),
    bossBlindEffectText: document.getElementById('boss-blind-effect-text'),
    targetingOverlay: document.getElementById('targeting-overlay'),
    targetingText: document.getElementById('targeting-text'),
    cancelTargetingButton: document.getElementById('cancel-targeting-button'),
    packOpeningArea: document.getElementById('pack-opening-area'),
    packOpeningTitle: document.getElementById('pack-opening-title'),
    packOpeningRarity: document.getElementById('pack-opening-rarity'),
    packOpeningInstruction: document.getElementById('pack-opening-instruction'),
    packOpeningChoices: document.getElementById('pack-opening-choices'),
        confirmPackChoiceButton: document.getElementById('confirm-pack-choice-button'),
        tooltip: document.getElementById('tooltip'),
    };

    DOMElements.lobbyNewRunButton.addEventListener('click', startNewRun);
    DOMElements.returnToLobbyButton.addEventListener('click', showLobby);
    DOMElements.playSetButton.addEventListener('click', playSet);
    DOMElements.discardButton.addEventListener('click', discard);
    DOMElements.closeShopButton.addEventListener('click', handleLeaveShop);
    DOMElements.cancelTargetingButton.addEventListener('click', cancelTargeting);
    DOMElements.confirmPackChoiceButton.addEventListener('click', handleConfirmPackChoice);

    DOMElements.jokerArea.addEventListener('dragstart', handleJokerDragStart);
    DOMElements.jokerArea.addEventListener('dragover', handleJokerDragOver);
    DOMElements.jokerArea.addEventListener('dragleave', handleJokerDragLeave);
    DOMElements.jokerArea.addEventListener('drop', handleJokerDrop);
    DOMElements.jokerArea.addEventListener('dragend', handleJokerDragEnd);

    document.getElementById('order-button-quantity').addEventListener('click', () => handleOrderButtonClick(2));
    document.getElementById('order-button-color').addEventListener('click', () => handleOrderButtonClick(0));
    document.getElementById('order-button-shape').addEventListener('click', () => handleOrderButtonClick(1));
    document.getElementById('order-button-shading').addEventListener('click', () => handleOrderButtonClick(3));

    DOMElements.orderButtons = {
        quantity: document.getElementById('order-button-quantity'),
        color: document.getElementById('order-button-color'),
        shape: document.getElementById('order-button-shape'),
        shading: document.getElementById('order-button-shading'),
    };
    // Store reference to the "Order by" buttons container
    DOMElements.orderContainer = document.querySelectorAll('#controls')[1];

    showLobby();
}

function showTooltip(content, event) {
    const tooltip = DOMElements.tooltip;
    tooltip.innerHTML = content;
    tooltip.classList.remove('hidden');
    updateTooltipPosition(event);
}

function hideTooltip() {
    DOMElements.tooltip.classList.add('hidden');
}

function updateTooltipPosition(event) {
    const tooltip = DOMElements.tooltip;
    if (tooltip.classList.contains('hidden')) return;

    const xOffset = 15;
    const yOffset = 15;
    
    // Ensure the tooltip doesn't go off-screen
    let left = event.clientX + xOffset;
    let top = event.clientY + yOffset;

    if (left + tooltip.offsetWidth > window.innerWidth) {
        left = event.clientX - tooltip.offsetWidth - xOffset;
    }
    if (top + tooltip.offsetHeight > window.innerHeight) {
        top = event.clientY - tooltip.offsetHeight - yOffset;
    }

    tooltip.style.left = `${left}px`;
    tooltip.style.top = `${top}px`;
}

function sortCardsByAttribute(attributeIndex) {
    const cards = Array.from(DOMElements.cardGrid.children);
    const cardDict = {}; // value: list[cardEl]
    cards.forEach(card => {
        const value = card.dataset.cardId.split('-')[attributeIndex];
        if (!cardDict[value]) {
            cardDict[value] = [];
        }
        cardDict[value].push(card);
    });

    // Sort the cardDict keys
    const sortedKeys = Object.keys(cardDict).sort((a, b) => a.localeCompare(b, undefined, { numeric: true }));

    // Clear the card grid
    DOMElements.cardGrid.innerHTML = '';

    // Append the sorted cards back to the grid
    sortedKeys.forEach(key => {
        cardDict[key].forEach(card => DOMElements.cardGrid.appendChild(card));
    });
}

function handleOrderButtonClick(attributeIndex) {
    if (!state.game || state.game.game_phase !== 'playing') return;

    sortCardsByAttribute(attributeIndex);
}

function renderCard(card, index) {
    const cardData = {
        color_val: card.attributes[0],
        shape_val: card.attributes[1],
        number_val: card.attributes[2],
        shading_val: card.attributes[3],
    };
    const cardEl = createCardElement(cardData, index);
    cardEl.dataset.index = index;
    cardEl.dataset.cardId = card.attributes.join('-'); // Unique ID for tracking

    if (card.enhancement) {
        const enhancementEl = document.createElement('div');
        enhancementEl.classList.add('enhancement-overlay');
        
        let text = '';
        let title = '';
        let className = '';

        switch (card.enhancement) {
            case 'bonus_chips':
                text = '+30 C';
                title = 'Bonus Card: +30 Chips when scored';
                className = 'enhancement-bonus';
                break;
            case 'bonus_mult':
                text = '+2 M';
                title = 'Mult Card: +2 Mult when scored';
                className = 'enhancement-mult';
                break;
            case 'x_mult':
                text = 'x1.5 M';
                title = 'X-Mult Card: x1.5 Mult when scored';
                className = 'enhancement-xmult';
                break;
            case 'gold':
                text = 'Gold';
                title = 'Gold Card: +$3 when scored';
                className = 'enhancement-gold';
                cardEl.classList.add('gold-card-background');
                break;
            case 'wildcard':
                text = 'WILD';
                title = 'Wildcard: Can be part of any Set.';
                className = 'enhancement-wild';
                cardEl.classList.add('wild-card-background');
                break;
        }

        if (text) {
            enhancementEl.textContent = text;
            enhancementEl.title = title;
            enhancementEl.classList.add(className);
            cardEl.appendChild(enhancementEl);
        }
    }
    
    cardEl.addEventListener('click', () => handleCardClick(index));
    
    return cardEl;
}

function renderJoker(joker, index, context = 'player') {
    const jokerEl = document.createElement('div');
    jokerEl.classList.add('joker-card', joker.rarity.toLowerCase());
    // Draggable only when not in shop and is a player joker
    if (context === 'player' && state.game.game_phase !== 'shop') {
        jokerEl.setAttribute('draggable', 'true');
    }
    jokerEl.dataset.index = index;
    
    const imageSrc = `/images/${joker.id}.webp`;

    jokerEl.innerHTML = `
        <div class="card-image-container">
            <img src="${imageSrc}" alt="${joker.name}" class="card-image" onerror="this.style.display='none'">
        </div>
    `;

    const tooltipContent = `<strong>${joker.name}</strong><br>${joker.description}`;
    jokerEl.addEventListener('mouseover', (event) => {
        showTooltip(tooltipContent, event);
    });
    jokerEl.addEventListener('mouseout', () => {
        hideTooltip();
    });
    jokerEl.addEventListener('mousemove', (event) => {
        updateTooltipPosition(event);
    });

    if (joker.display_badge) {
        const badgeEl = document.createElement('div');
        badgeEl.classList.add('joker-badge');
        badgeEl.textContent = joker.display_badge;
        badgeEl.title = joker.description;
        jokerEl.appendChild(badgeEl);
    }

    // Add sell button if it's a player's joker and we are in the shop phase
    if (context === 'player' && state.game && state.game.game_phase === 'shop') {
        const sellButton = document.createElement('button');
        sellButton.classList.add('sell-joker-button');
        // In a real game, you'd fetch these prices from a config.
        // For now, let's hardcode based on the backend logic.
        const rarityPrices = { 'Common': 4, 'Uncommon': 6, 'Rare': 8, 'Legendary': 10 };
        const sellPrice = Math.floor((rarityPrices[joker.rarity] || 4) / 2);
        sellButton.textContent = `Sell ($${sellPrice})`;
        sellButton.addEventListener('click', (e) => {
            e.stopPropagation(); // Prevent card click events
            handleSellJoker(index);
        });
        jokerEl.appendChild(sellButton);
    }

    console.log(`Rendering joker: ${joker.name} (ID: ${joker.id}, Variant: ${joker.variant})`);
    if (joker.variant != "basic") {
        const variantEL = document.createElement('div');
        variantEL.classList.add('variant-overlay');

        let text = '';
        let title = '';

        switch (joker.variant) {
            case 'foil':
                text = '+30 C';
                title = "Foil: +30 Chips";
                break;
            case 'holographic':
                text = '+3 M';
                title = "Holographic: +3 Mult";
                break;
            case 'polychrome':
                text = 'x1.5 M';
                title = 'Polychrome: x1.5 Mult';
                break;
            case 'negative':
                text = 'NEGATIVE';
                title = "Negative: Grants one additional joker slot"
                break;
        }

        if (text) {
            variantEL.textContent = text;
            variantEL.title = title;
            variantEL.classList.add(joker.variant.toLowerCase());
            variantEL.top = "20%";
            jokerEl.appendChild(variantEL);
        }
    }

    return jokerEl;
}

function updateScoreDisplay(score, targetScore) {
    const currentScore = Math.floor(score);
    const requiredScore = Math.floor(targetScore);

    DOMElements.currentScore.textContent = currentScore;
    DOMElements.requiredScore.textContent = requiredScore;

    // Update progress bar
    if (requiredScore > 0) {
        const progress = Math.min(currentScore / requiredScore, 1);
        DOMElements.scoreProgressBar.style.width = `${progress * 100}%`;
    } else {
        DOMElements.scoreProgressBar.style.width = '0%';
    }
}

function updateUI(gameState, oldGameState = { round_score: 0, board: [] }, isMidAnimation = false) {
    state.game = gameState;
    // Show or hide "Order by" buttons container based on phase
    if (DOMElements.orderContainer) {
        DOMElements.orderContainer.style.display = (gameState.game_phase === 'playing') ? 'flex' : 'none';
    }

    // If we are in the middle of another animation (like scoring),
    // just update the state object and bail. The full UI render will be called later.
    if (isMidAnimation) {
        return;
    }

    // Update stats display
    DOMElements.moneyValue.textContent = gameState.money;
    DOMElements.anteValue.textContent = gameState.ante;
    DOMElements.blindType.textContent = gameState.current_blind;
    DOMElements.requiredScore.textContent = gameState.blind_score_required;
    DOMElements.boardsRemaining.textContent = gameState.boards_remaining;
    DOMElements.discardsRemaining.textContent = gameState.discards_remaining;

    // Update score display
    updateScoreDisplay(gameState.round_score, gameState.blind_score_required);

    // Handle boss blind display
    if (gameState.boss_blind_effect) {
        DOMElements.bossBlindEffectDisplay.classList.remove('hidden');
        const effectDescriptions = {
            "debuff_first_joker": "First Joker is disabled",
            "reduce_board_size": "Board size is reduced to 9"
        };
        DOMElements.bossBlindEffectText.textContent = effectDescriptions[gameState.boss_blind_effect] || gameState.boss_blind_effect;
    } else {
        DOMElements.bossBlindEffectDisplay.classList.add('hidden');
    }

    // Render Jokers
    DOMElements.jokerArea.innerHTML = '';
    gameState.jokers.forEach((joker, index) => {
        const jokerEl = renderJoker(joker, index, 'player');
        DOMElements.jokerArea.appendChild(jokerEl);
    });

    // Render Consumables
    DOMElements.consumableArea.innerHTML = '';
    gameState.consumables.forEach((consumable, index) => {
        const consumableEl = renderConsumable(consumable, index);
        DOMElements.consumableArea.appendChild(consumableEl);
    });

    // Handle different game phases
    const isShop = gameState.game_phase === 'shop';
    const isTargeting = gameState.game_phase === 'targeting_card';
    const isPackOpening = gameState.game_phase === 'pack_opening';

    DOMElements.shopArea.classList.toggle('hidden', !isShop);
    DOMElements.packOpeningArea.classList.toggle('hidden', !isPackOpening);
    DOMElements.targetingOverlay.classList.toggle('hidden', !isTargeting);
    DOMElements.scoreProgressContainer.style.visibility = (isShop || isPackOpening) ? 'hidden' : 'visible';

    DOMElements.controls.style.display = (isShop || isTargeting || isPackOpening) ? 'none' : 'flex';
    DOMElements.boardArea.style.display = (isShop || isPackOpening) ? 'none' : 'block';

    if (isShop) {
        renderShop(gameState);
        return; // Stop further UI updates
    }

    if (isPackOpening) {
        renderPackOpening(gameState.pack_opening_state);
        return;
    }
    
    if (isTargeting) {
        const consumableName = state.game.consumables[state.game.active_consumable_index].name;
        DOMElements.targetingText.textContent = `Select a card on your board to apply ${consumableName}.`;
    }

    if (gameState.game_phase === 'game_over') {
        showMsg("Game Over! You failed to meet the score.");
        DOMElements.controls.style.display = 'none';
        DOMElements.endRunContainer.style.display = 'block';
        return;
    }
    
    if (gameState.game_phase === 'run_won') {
        showMsg("Congratulations! You won the run!");
        DOMElements.controls.style.display = 'none';
        DOMElements.endRunContainer.style.display = 'block';
        return;
    }


    // --- Card Position Animation (FLIP) ---
    const oldPositions = {};
    const currentCardElements = Array.from(DOMElements.cardGrid.children);
    currentCardElements.forEach(cardEl => {
        // Only get positions for cards that are not currently flying out.
        if (!cardEl.style.opacity || parseFloat(cardEl.style.opacity) > 0) {
             oldPositions[cardEl.dataset.cardId] = cardEl.getBoundingClientRect();
        }
    });

    // Re-render the grid with new cards
    DOMElements.cardGrid.innerHTML = '';
    gameState.board.forEach((card, index) => {
        const cardEl = renderCard(card, index);
        if (gameState.game_phase === 'targeting_card') {
            cardEl.classList.add('targetable');
        }
        DOMElements.cardGrid.appendChild(cardEl);
    });

    // Animate positions
    Array.from(DOMElements.cardGrid.children).forEach(cardEl => {
        const oldPos = oldPositions[cardEl.dataset.cardId];
        const newPos = cardEl.getBoundingClientRect();

        if (oldPos) { // This card was already on the board, animate its movement
            const dx = oldPos.left - newPos.left;
            const dy = oldPos.top - newPos.top;

            if (dx !== 0 || dy !== 0) {
                requestAnimationFrame(() => {
                    cardEl.style.transform = `translate(${dx}px, ${dy}px)`;
                    cardEl.style.transition = 'transform 0s';
                    requestAnimationFrame(() => {
                        cardEl.style.transform = '';
                        cardEl.style.transition = 'transform 0.5s ease-out';
                    });
                });
            }
        } else { // This is a new card
            cardEl.classList.add('deal-in');
        }
    });

    updateButtons();
}

function handleCardClick(index) {
    // The 'targeting_card' game phase logic was incomplete and not fully supported
    // by the backend. It's being replaced by a more generic selection mechanism where
    // the user selects cards first, then clicks the consumable to use.

    if (state.game.game_phase !== 'playing') return;

    if (state.selectedCards.has(index)) {
        state.selectedCards.delete(index);
    } else {
        state.selectedCards.add(index);
    }
    
    const cardEl = DOMElements.cardGrid.querySelector(`[data-index="${index}"]`);
    if (cardEl) {
        cardEl.classList.toggle('selected');
    }
    
    updateButtons();
}

function updateButtons() {
    if (!state.game || state.game.game_phase !== 'playing') {
        DOMElements.playSetButton.disabled = true;
        DOMElements.discardButton.disabled = true;
        Object.values(DOMElements.orderButtons).forEach(button => {
            button.disabled = true;
        });
        return;
    }
    const selectedCount = state.selectedCards.size;
    DOMElements.playSetButton.disabled = selectedCount !== 3;
    DOMElements.discardButton.disabled = !(selectedCount > 0 && selectedCount <= 5) || state.game.discards_remaining <= 0;
}

async function playSet() {
    console.log("playSet function called");
    if (state.selectedCards.size !== 3) return;

    DOMElements.playSetButton.disabled = true;
    const oldState = { ...state.game };
    const indices = Array.from(state.selectedCards);
    const selectedCardsData = indices.map(i => oldState.board[i]);

    const cardElements = indices.map(i => DOMElements.cardGrid.querySelector(`[data-index="${i}"]`));

    try {
        console.log("Calling api.playSet");
        const { game_state: newState, scoring_details: scoringDetails } = await api.playSet(state.gameId, indices);
        console.log("api.playSet returned");
        state.selectedCards.clear();

        // Run the scoring animation first. We pass the newState to it so it knows the final score.
        // This prevents the UI from updating instantly before the animation.
        await showScoringAnimation(cardElements, selectedCardsData, scoringDetails, oldState, newState);

        console.log("Scoring animation finished, performing final UI update.");
        // Now that the animation is done, update the state and do a full UI render.
        updateUI(newState, oldState);

    } catch (error) {
        console.error("Error in playSet:", error);
        showMsg(error.message || "Failed to play set.");
        DOMElements.playSetButton.disabled = false;
        shakeSelectedCards();
        // Ensure cards are visible if an error occurs before fly-out
        cardElements.forEach(el => el.classList.remove('fly-out'));
    }
}

async function discard() {
    const selectedCount = state.selectedCards.size;
    if (selectedCount === 0) return;

    DOMElements.discardButton.disabled = true;
    const oldState = { ...state.game };
    const indices = Array.from(state.selectedCards);

    try {
        const { game_state: newGameState } = await api.discard(state.gameId, indices);
        state.selectedCards.clear();
        updateUI(newGameState, oldState);
    } catch (error) {
        console.error("Error in discard:", error);
        showMsg(error.message || "Failed to discard cards.");
        shakeSelectedCards();
    } finally {
        // Re-enable button regardless of success or failure, as the state will be updated.
        updateButtons();
    }
}

async function startNewRun() {
    try {
        const newGame = await api.newRun();
        if (newGame && newGame.id) {
            await loadGame(newGame.id, newGame);
        } else {
            throw new Error("New run data is invalid.");
        }
    } catch (error) {
        showMsg("Failed to start a new run.");
        console.error(error);
    }
}

async function handleLeaveShop() {
    try {
        const { game_state: newGameState } = await api.leaveShop(state.gameId);
        updateUI(newGameState);
    } catch (error) {
        console.error("Error leaving shop:", error);
        showMsg("Failed to continue to next round.");
    }
}

async function handleBuyJoker(slotIndex) {
    try {
        const { game_state: newGameState } = await api.buyJoker(state.gameId, slotIndex);
        updateUI(newGameState); // This will re-render the shop with the updated state
    } catch (error) {
        console.error("Error buying joker:", error);
        showMsg(error.message || "Failed to buy joker.");
    }
}

async function handleSellJoker(jokerIndex) {
    try {
        const { game_state: newGameState, message } = await api.sellJoker(state.gameId, jokerIndex);
        if (message) showMsg(message);
        updateUI(newGameState); // Re-render the shop and player state
    } catch (error) {
        console.error("Error selling joker:", error);
        showMsg(error.message || "Failed to sell joker.");
    }
}

async function handleBuyBoosterPack(slotIndex) {
    try {
        const { game_state: newGameState } = await api.buyBoosterPack(state.gameId, slotIndex);
        updateUI(newGameState); // This will now trigger renderPackOpening
    } catch (error) {
        console.error("Error buying booster pack:", error);
        showMsg(error.message || "Failed to buy booster pack.");
    }
}

async function handleUseConsumable(consumableIndex) {
    const consumable = state.game.consumables[consumableIndex];
    if (!consumable) return;

    const targetCount = consumable.target_count || 0;
    const indices = Array.from(state.selectedCards);

    if (targetCount > 0) {
        if (indices.length !== targetCount) {
            showMsg(`Please select exactly ${targetCount} card(s) to use ${consumable.name}.`);
            return;
        }
    }

    try {
        hideTooltip();
        // For consumables that don't need a target, indices will be an empty array, which is fine.
        const { game_state: newGameState, message } = await api.useConsumable(state.gameId, consumableIndex, indices);
        if (message) showMsg(message);
        
        // Clear selection after successful use
        if (indices.length > 0) {
            state.selectedCards.clear();
        }

        updateUI(newGameState);
    } catch (error) {
        console.error("Error using consumable:", error);
        showMsg(error.message || "Failed to use consumable.");
    }
}

function renderConsumable(consumable, index) {
    const consumableEl = document.createElement('div');
    consumableEl.classList.add('consumable-card', consumable.rarity.toLowerCase());

    const imageSrc = `/images/${consumable.id}.webp`;

    consumableEl.innerHTML = `
        <div class="card-image-container">
            <img src="${imageSrc}" alt="${consumable.name}" class="card-image" onerror="this.style.display='none'">
        </div>
    `;
    consumableEl.addEventListener('click', () => handleUseConsumable(index));

    // Tooltip implementation
    const tooltipContent = `<strong>${consumable.name}</strong><br>${consumable.tooltip || consumable.description}`;

    consumableEl.addEventListener('mouseover', (event) => {
        showTooltip(tooltipContent, event);
    });
    consumableEl.addEventListener('mouseout', () => {
        hideTooltip();
    });
    consumableEl.addEventListener('mousemove', (event) => {
        updateTooltipPosition(event);
    });

    return consumableEl;
}

function renderShop(gameState) {
    DOMElements.cardItems.innerHTML = '';
    DOMElements.packItems.innerHTML = '';
    const { shop_state, money, jokers, joker_slots } = gameState;

    shop_state.joker_slots.forEach((slot, index) => {
        const shopItemEl = document.createElement('div');
        shopItemEl.classList.add('shop-item');

        if (slot.item) {
            const jokerEl = renderJoker(slot.item, index, 'shop');
            shopItemEl.appendChild(jokerEl);

            const buyButton = document.createElement('button');
            buyButton.textContent = `Buy ($${slot.price})`;
            buyButton.disabled = slot.is_purchased || money < slot.price || jokers.length >= joker_slots;
            
            if (slot.is_purchased) {
                buyButton.textContent = 'Sold';
            } else if (jokers.length >= joker_slots) {
                 buyButton.textContent = 'Slots Full';
            }

            buyButton.addEventListener('click', () => handleBuyJoker(index));
            shopItemEl.appendChild(buyButton);
        }
        
        DOMElements.cardItems.appendChild(shopItemEl);
    });

    // Render Booster Packs
    shop_state.booster_pack_slots.forEach((pack, index) => {
        const shopItemEl = document.createElement('div');
        shopItemEl.classList.add('shop-item');

        if(pack) {
            const packItem = document.createElement('div');
            packItem.classList.add('booster-pack-item');
            packItem.innerHTML = `<div class="name">${pack.name}</div>`;
            shopItemEl.appendChild(packItem);

            const buyButton = document.createElement('button');
            buyButton.textContent = `Buy ($${pack.price})`;
            buyButton.disabled = pack.is_purchased || money < pack.price;

            if (pack.is_purchased) {
                buyButton.textContent = 'Sold';
            }

            buyButton.addEventListener('click', () => handleBuyBoosterPack(index));
            shopItemEl.appendChild(buyButton);

        }
        DOMElements.packItems.appendChild(shopItemEl);
    });
}

async function cancelTargeting() {
    try {
        // Just get the latest state from the server, which will have the correct phase
        const newGameState = await api.getState(state.gameId);
        updateUI(newGameState);
    } catch (error) {
        console.error("Error cancelling targeting:", error);
        showMsg("Failed to cancel action. Please refresh.");
    }
}

function showLobby() {
    DOMElements.gameContainer.style.display = 'none';
    DOMElements.lobbyContainer.classList.remove('hidden');
    DOMElements.endRunContainer.style.display = 'none';

    api.getSaves().then(data => {
        renderLobby(data.saves);
    }).catch(err => {
        console.error("Failed to fetch saves:", err);
        showMsg("Could not connect to the server.");
        DOMElements.savesList.innerHTML = '<p>Error loading saves.</p>';
    });
}

async function loadGame(id, gameState = null) {
    try {
        state.gameId = id;
        const gameToLoad = gameState || await api.getState(id);

        DOMElements.lobbyContainer.classList.add('hidden');
        DOMElements.gameContainer.style.display = 'flex';
        DOMElements.endRunContainer.style.display = 'none';
        
        // Reset UI elements that might persist from previous games
        DOMElements.controls.style.display = 'flex';
        DOMElements.boardArea.style.display = 'block';
        DOMElements.shopArea.classList.add('hidden');

        DOMElements.scoreProgress = document.getElementById('score-progress-container');

        updateUI(gameToLoad);
    } catch (error) {
        showMsg("Failed to load game.");
        console.error(error);
        showLobby(); // Go back to lobby on error
    }
}

function renderLobby(saves) {
    DOMElements.savesList.innerHTML = '';
    if (!saves || saves.length === 0) {
        DOMElements.savesList.innerHTML = '<li>No saved games found. Start a new run!</li>';
        return;
    }

    saves.forEach(save => {
        console.log("Rendering save:", save);
        const saveEl = document.createElement('li');
        saveEl.classList.add('save-game-entry');
        saveEl.innerHTML = `
            <div class="save-info">
                <span class="save-id">ID: ${save.id.substring(0, 8)}</span>
                <span class="save-ante">Ante: ${save.ante || 1}</span>
                <span class="save-blind">Blind: ${save.current_blind || 'N/A'}</span>
                <span class="save-phase">Phase: ${save.game_phase}</span>
                <span class="save-money">Money: $${save.money}</span>
            </div>
            <button class="continue-button">Continue</button>
        `;
        saveEl.querySelector('.continue-button').addEventListener('click', () => loadGame(save.id));
        const deleteBtn = document.createElement('button');
        deleteBtn.classList.add('delete-button');
        deleteBtn.textContent = 'Delete';
        deleteBtn.addEventListener('click', async () => {
            try {
                await api.deleteSave(save.id);
                showLobby();
            } catch (e) {
                showMsg('Failed to delete save.');
            }
        });
        saveEl.appendChild(deleteBtn);
        DOMElements.savesList.appendChild(saveEl);
    });
}

function handleJokerDragStart(event) {
    const target = event.target.closest('.joker-card');
    if (target) {
        draggedJokerIndex = parseInt(target.dataset.index, 10);
        event.dataTransfer.effectAllowed = 'move';
        // Add a class for styling the dragged element
        setTimeout(() => {
            target.classList.add('dragging');
        }, 0);
    }
}

function handleJokerDragOver(event) {
    event.preventDefault();
    const container = DOMElements.jokerArea;
    const activeItem = container.querySelector('.dragging');
    if (!activeItem) return;

    const overElement = event.target.closest('.joker-card');
    
    // Find all non-dragging items
    const siblings = [...container.querySelectorAll('.joker-card:not(.dragging)')];

    // Find the sibling the cursor is over
    const nextSibling = siblings.find(sibling => {
        const rect = sibling.getBoundingClientRect();
        // Check if the cursor is in the left half of the sibling
        return event.clientX < rect.left + rect.width / 2;
    });

    // Insert the active item before the identified sibling or at the end
    if (nextSibling) {
        container.insertBefore(activeItem, nextSibling);
    } else {
        container.appendChild(activeItem);
    }
}

function handleJokerDragLeave(event) {
    // This can help remove styles if the user drags out of the container
}

function handleJokerDragEnd(event) {
    const target = event.target.closest('.joker-card');
    if (target) {
        target.classList.remove('dragging');
    }
    draggedJokerIndex = null;
}

async function handleJokerDrop(event) {
    event.preventDefault();
    if (draggedJokerIndex === null) return;

    const jokerElements = [...DOMElements.jokerArea.querySelectorAll('.joker-card')];
    const newOrder = jokerElements.map(j => parseInt(j.dataset.index, 10));

    // The visual reordering is already done in dragOver.
    // Now, we just need to send the final order to the backend.

    // Clean up visual styles immediately
    const draggedElement = jokerElements.find(j => parseInt(j.dataset.index, 10) === draggedJokerIndex);
    if (draggedElement) {
        draggedElement.classList.remove('dragging');
    }
    
    draggedJokerIndex = null;

    try {
        // We don't need the response if it's just the same state
        await api.reorderJokers(state.gameId, newOrder);
        // The UI is already visually updated, so we just need to refresh the state
        // in the background for consistency, or trust the visual update.
        // For simplicity, we'll fetch the new state to be safe.
        const newGameState = await api.getState(state.gameId);
        updateUI(newGameState);

    } catch (error) {
        console.error("Error reordering jokers:", error);
        showMsg(error.message || "Failed to reorder jokers.");
        // Revert to original UI on failure by re-rendering the last known good state
        updateUI(state.game);
    }
}


function animateValue(element, from, to, duration = 400, isFloat = false) {
    return new Promise(resolve => {
        const isScoreElement = element === DOMElements.currentScore;

        const updateProgressBar = (score) => {
            if (!isScoreElement) return;
            const requiredScore = state.game.blind_score_required || 1; // Avoid division by zero
            const percentage = (score / requiredScore) * 100;
            DOMElements.scoreProgressBar.style.width = `${Math.min(percentage, 100)}%`;
        };

        if (from === to) {
            element.textContent = isFloat ? to.toFixed(2) : Math.round(to);
            updateProgressBar(to);
            resolve();
            return;
        }
        const start = performance.now();

        function frame(time) {
            const elapsed = time - start;
            const progress = Math.min(elapsed / duration, 1);
            const currentValue = from + (to - from) * progress;
            element.textContent = isFloat ? currentValue.toFixed(2) : Math.round(currentValue);
            updateProgressBar(currentValue);

            if (progress < 1) {
                requestAnimationFrame(frame);
            } else {
                resolve();
            }
        }
        requestAnimationFrame(frame);
    });
}

function animateScore(from, to) {
    // This is a fire-and-forget animation.
    // We don't check from === to because animateValue handles it,
    // and we need it to run to ensure the display is correct even if the value hasn't changed.
    animateValue(DOMElements.currentScore, from, to, 500, false);
}

function shakeSelectedCards() {
    state.selectedCards.forEach(index => {
        const cardEl = DOMElements.cardGrid.querySelector(`[data-index="${index}"]`);
        if (cardEl) {
            cardEl.classList.add('shake');
            setTimeout(() => cardEl.classList.remove('shake'), 500);
        }
    });
}

function createScorePopup(text, type, x, y) {
    console.log("Creating score popup:", { text, type, x, y });
    const containerRect = DOMElements.gameContainer.getBoundingClientRect();
    const popup = document.createElement('div');
    popup.textContent = text;
    popup.classList.add('score-popup', ...type.split(' '));
    popup.style.left = `${x - containerRect.left}px`;
    popup.style.top = `${y - containerRect.top}px`;
    DOMElements.gameContainer.appendChild(popup);
    setTimeout(() => popup.remove(), 1400);
}

async function showScoringAnimation(selectedCardElements, selectedCardsData, scoringDetails, oldState, newState) {
    const { score_log = [], score_gained = 0 } = scoringDetails || {};
    console.log("showScoringAnimation called with:", {
        selectedCardElements,
        selectedCardsData,
        score_log,
        score_gained
    });

    // --- Setup Scoring Display ---
    DOMElements.scoringDisplay.innerHTML = `
        <div class="scoring-calculation">
             <div class="scoring-total">
                <span id="scoring-chips">0</span> <span class="scoring-x">x</span> <span id="scoring-mult">0</span> = <span id="scoring-total-value">0</span>
            </div>
        </div>
        <div id="scoring-log-area"></div>
        <div class="final-score-gained">Score Gained: <span id="final-score-value">0</span></div>
    `;
    const scoringChipsEl = document.getElementById('scoring-chips');
    const scoringMultEl = document.getElementById('scoring-mult');
    const scoringTotalValueEl = document.getElementById('scoring-total-value');
    const scoringLogAreaEl = document.getElementById('scoring-log-area');
    const finalScoreValueEl = document.getElementById('final-score-value');

    DOMElements.scoringDisplay.classList.remove('hidden', 'hide');
    DOMElements.scoringDisplay.classList.add('show');

    // --- Group score log entries by sequence ---
    const groupedEntries = [];
    let currentGroup = [];
    let currentCardIndex = 0;
    
    for (const entry of score_log) {
        if (entry.source_type === 'set') {
            // Base set score - always first
            groupedEntries.push([entry]);
        } else if (entry.source_type === 'card') {
            // Card enhancement - start new card group
            if (currentGroup.length > 0) {
                groupedEntries.push(currentGroup);
            }
            currentGroup = [entry];
        } else if (entry.source_type === 'joker') {
            if (entry.trigger_phase === 'card_scoring') {
                // Card-triggered joker - add to current card group
                currentGroup.push(entry);
            } else if (entry.trigger_phase === 'end_scoring') {
                // End-of-scoring joker - finalize current group and start end group
                if (currentGroup.length > 0) {
                    groupedEntries.push(currentGroup);
                    currentGroup = [];
                }
                groupedEntries.push([entry]);
            }
        }
    }
    
    // Add any remaining card group
    if (currentGroup.length > 0) {
        groupedEntries.push(currentGroup);
    }

    console.log("Grouped scoring entries:", groupedEntries);

    // --- Animate Cards and Process Groups in Sequence ---
    let cardIndex = 0;
    let lastChips = 0;
    let lastMult = 0;

    for (const group of groupedEntries) {
        const firstEntry = group[0];
        
        // If this is a card-related group, animate the card flying away first
        if (firstEntry.source_type === 'card' && cardIndex < selectedCardElements.length) {
            const cardEl = selectedCardElements[cardIndex];
            if (cardEl) {
                console.log(`Animating card ${cardIndex} flying away`);
                cardEl.style.transition = 'transform 0.5s ease-in, opacity 0.5s ease-in';
                cardEl.style.transform = 'translateY(-200px) scale(0.8)';
                cardEl.style.opacity = '0';
                
                // Wait for card animation
                await new Promise(resolve => setTimeout(resolve, 550));
            }
            cardIndex++;
        }

        // Process all entries in this group
        for (const logEntry of group) {
            // Pause before processing each entry
            await new Promise(resolve => setTimeout(resolve, 450));

            console.log("Processing log entry:", logEntry);

            // Create and animate log entry element
            const logEl = document.createElement('div');
            logEl.classList.add('scoring-log-entry');
            
            // Add special styling based on trigger phase
            if (logEntry.trigger_phase === 'card_scoring') {
                logEl.classList.add('card-triggered');
            } else if (logEntry.trigger_phase === 'end_scoring') {
                logEl.classList.add('end-triggered');
            }
            
            logEl.innerHTML = `
                <span class="source-name ${logEntry.source_type || 'unknown'}">${logEntry.source_name || 'Unknown'}</span>
                <span class="description">${logEntry.description || ''}</span>
            `;
            scoringLogAreaEl.prepend(logEl);

            // Determine the source element for highlighting and popup
            let sourceEl = null;
            if (logEntry.source_type === 'joker') {
                sourceEl = Array.from(DOMElements.jokerArea.children).find(j => {
                    const img = j.querySelector('img');
                    return img && img.alt === logEntry.source_name;
                });
            } else if (logEntry.source_type === 'card' || logEntry.source_type === 'set') {
                sourceEl = scoringTotalValueEl;
            }

            // Trigger highlight and popup animation
            if (sourceEl) {
                const highlightClass = logEntry.trigger_phase === 'card_scoring' ? 'card-trigger-highlight' : 'highlight';
                sourceEl.classList.add(highlightClass);
                setTimeout(() => sourceEl.classList.remove(highlightClass), 700);

                const rect = sourceEl.getBoundingClientRect();
                const popupX = rect.left + rect.width / 2;
                const popupY = rect.top;
                
                // Determine popup type and styling
                let popupType = 'chips';
                if (logEntry.description.includes('Mult')) {
                    popupType = logEntry.description.includes('x') ? 'xmult' : 'mult';
                }
                if (logEntry.trigger_phase === 'card_scoring') {
                    popupType += ' card-trigger';
                }
                
                createScorePopup(logEntry.description, popupType, popupX, popupY);
            }

            // Animate the main score values
            const newChips = logEntry.chips_after !== undefined ? logEntry.chips_after : lastChips;
            const newMult = logEntry.mult_after !== undefined ? logEntry.mult_after : lastMult;

            await Promise.all([
                animateValue(scoringChipsEl, lastChips, newChips, 400, false),
                animateValue(scoringMultEl, lastMult, newMult, 400, true)
            ]);

            lastChips = newChips;
            lastMult = newMult;

            // Update the total immediately after sub-values finish animating
            scoringTotalValueEl.textContent = Math.floor(lastChips * lastMult);
        }
    }

    // Animate any remaining cards that weren't triggered by card enhancements
    while (cardIndex < selectedCardElements.length) {
        const cardEl = selectedCardElements[cardIndex];
        if (cardEl) {
            cardEl.style.transition = 'transform 0.5s ease-in, opacity 0.5s ease-in';
            cardEl.style.transform = 'translateY(-200px) scale(0.8)';
            cardEl.style.opacity = '0';
        }
        cardIndex++;
    }

    // --- Show Final Score ---
    finalScoreValueEl.textContent = Math.floor(score_gained);
    finalScoreValueEl.parentElement.classList.add('show-final');

    // --- Hide Scoring Display ---
    await new Promise(resolve => setTimeout(resolve, 3000)); // Wait to show final score
    DOMElements.scoringDisplay.classList.remove('show');
    DOMElements.scoringDisplay.classList.add('hide');
    await new Promise(resolve => setTimeout(resolve, 300)); // Wait for hide animation
    DOMElements.scoringDisplay.classList.add('hidden');
}

function renderPackOpening(packState) {
    if (!packState) {
        DOMElements.packOpeningArea.classList.add('hidden');
        return;
    }

    console.log("Rendering pack opening with state:", packState);

    state.selectedPackChoices.clear(); // Reset selections

    DOMElements.packOpeningTitle.textContent = `Opening ${packState.pack_type}`;
    DOMElements.packOpeningRarity.textContent = packState.rarity;
    DOMElements.packOpeningRarity.className = 'pack-opening-rarity'; // Clear old classes
    DOMElements.packOpeningRarity.classList.add(packState.rarity);

    DOMElements.packOpeningInstruction.textContent = `Choose ${packState.choose}:`;

    DOMElements.packOpeningChoices.innerHTML = '';
    packState.choices.forEach(choice => {
        // A tarot card is basically a consumable. Let's treat it like one.
        const cardEl = document.createElement('div');
        // Use consumable-card for styling, but add pack-choice for selection logic
        cardEl.classList.add('consumable-card', 'pack-choice', packState.rarity.toLowerCase());
        cardEl.dataset.id = choice.id;

        const imageSrc = `/images/${choice.id}.webp`;

        cardEl.innerHTML = `
            <div class="card-image-container">
                <img src="${imageSrc}" alt="${choice.name}" class="card-image" onerror="this.style.display='none'">
            </div>
        `;
        
        const tooltipContent = `<strong>${choice.name}</strong><br>${choice.description}`;
        cardEl.addEventListener('mouseover', (event) => showTooltip(tooltipContent, event));
        cardEl.addEventListener('mouseout', hideTooltip);
        cardEl.addEventListener('mousemove', updateTooltipPosition);

        cardEl.addEventListener('click', () => handlePackChoiceClick(choice.id, packState.choose));
        DOMElements.packOpeningChoices.appendChild(cardEl);
    });

    DOMElements.confirmPackChoiceButton.disabled = true;
}

function handlePackChoiceClick(choiceId, chooseLimit) {
    const choiceEl = DOMElements.packOpeningChoices.querySelector(`.pack-choice[data-id="${choiceId}"]`);
    if (!choiceEl) return;

    if (state.selectedPackChoices.has(choiceId)) {
        state.selectedPackChoices.delete(choiceId);
        choiceEl.classList.remove('selected');
    } else {
        if (state.selectedPackChoices.size < chooseLimit) {
            state.selectedPackChoices.add(choiceId);
            choiceEl.classList.add('selected');
        }
    }

    DOMElements.confirmPackChoiceButton.disabled = state.selectedPackChoices.size === 0;
}

async function handleConfirmPackChoice() {
    const selectedIds = Array.from(state.selectedPackChoices);
    if (selectedIds.length === 0) return;

    console.log("Confirming pack choice with IDs:", selectedIds);

    DOMElements.confirmPackChoiceButton.disabled = true;

    try {
        const { game_state: newGameState, message } = await api.choosePackReward(state.gameId, selectedIds);
        updateUI(newGameState);
    } catch (error) {
        console.error("Error confirming pack choice:", error);
        showMsg(error.message || "Failed to select reward.");
        DOMElements.confirmPackChoiceButton.disabled = false;
    }
}

document.addEventListener('DOMContentLoaded', init);

// === DEV CHEAT FUNCTIONS ===
// Usage in browser console: setMoney(100), giveJoker("J_CHIPS"), giveTarot("T_THE_EMPRESS")
window.setMoney = async function(amount) {
    if (!state.gameId) {
        console.error("No game loaded.");
        return;
    }
    try {
        const res = await fetch(`/api/balatro/set_money?id=${state.gameId}&amount=${amount}`, { method: 'POST' });
        if (!res.ok) throw new Error("Failed to set money");
        const data = await res.json();
        updateUI(data.game_state);
        console.log("Money set to", amount);
    } catch (e) {
        console.error(e);
    }
};

window.giveJoker = async function(jokerId) {
    if (!state.gameId) {
        console.error("No game loaded.");
        return;
    }
    try {
        const res = await fetch(`/api/balatro/give_joker?id=${state.gameId}&joker_id=${jokerId}`, { method: 'POST' });
        if (!res.ok) throw new Error("Failed to give joker");
        const data = await res.json();
        updateUI(data.game_state);
        console.log("Gave joker", jokerId);
    } catch (e) {
        console.error(e);
    }
};

window.giveTarot = async function(tarotId) {
    if (!state.gameId) {
        console.error("No game loaded.");
        return;
    }
    try {
        const res = await fetch(`/api/balatro/give_tarot?id=${state.gameId}&tarot_id=${tarotId}`, { method: 'POST' });
        if (!res.ok) throw new Error("Failed to give tarot");
        const data = await res.json();
        updateUI(data.game_state);
        console.log("Gave tarot", tarotId);
    } catch (e) {
        console.error(e);
    }
};



================================================
FILE: static/challenge.html
================================================
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Set - Challenge Mode</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <div id="back-button-container">
        <button id="back-button"><-</button>
    </div>
    <div id="game-container">
        <div id="game-board" class="hidden">
            <div id="game-controls">
                <div id="stats">
                    <p id="challenge-stats">Sets: <span id="sets-found">0</span> / <span id="sets-total">0</span></p>
                </div>
                <button id="hint-button">Hint</button>
            </div>
            <div id="game-area">
                <div id="card-grid"></div>
                <div id="challenge-sets-container">
                    <h3>All Sets</h3>
                    <div id="all-sets-list"></div>
                </div>
            </div>
        </div>
    </div>

    <div id="error-dialog" class="hidden">
        <div class="modal-content error-content">
            <p class="error-message"></p>
            <button class="error-close-btn">OK</button>
        </div>
    </div>

    <script src="app.js" type="module"></script>
    <script src="challenge.js" type="module"></script>
</body>
</html>



================================================
FILE: static/challenge.js
================================================
import * as game from './app.js';


document.addEventListener('DOMContentLoaded', () => {
    game.hintButton.addEventListener('click', () => game.getHint('challenge'));
    startGame();
});

function startGame() {
    console.log("Starting challenge game...");
    game.gameBoardDiv.classList.remove('hidden');
    game.challengeStats.classList.remove('hidden');
    game.challengeSetsContainer.classList.remove('hidden');
    game.setFoundSets([]);
    game.setSeed(new URLSearchParams(window.location.search).get('seed') || null);

    game.dealInitialCards('challenge');
}



================================================
FILE: static/index.html
================================================
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Set - Game Menu</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <div id="game-container">
        <div id="setup">
            <input type="text" id="seed-input" placeholder="Enter seed (optional)">

            <h1>Select a Game Mode</h1>
            <div class="mode-selection">
                <button onclick="document.location.href='timed.html?seed=' + document.getElementById('seed-input').value" class="start-button">Timed Mode</button>
                <button onclick="document.location.href='infinite.html?seed=' + document.getElementById('seed-input').value" class="start-button">Infinite Mode</button>
                <button onclick="document.location.href='challenge.html?seed=' + document.getElementById('seed-input').value" class="start-button">Challenge Mode</button>
                <button onclick="document.location.href='balatro.html?seed=' + document.getElementById('seed-input').value" class="start-button">Balatro Mode</button>
            </div>
        </div>
    </div>
</body>
</html>



================================================
FILE: static/infinite.html
================================================
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Set - Infinite Mode</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <div id="back-button-container">
        <button id="back-button"><-</button>
    </div>
    <div id="game-container">
        <div id="game-board" class="hidden">
            <div id="game-controls">
                <div id="stats">
                    <p>Score: <span id="score">0</span></p>
                </div>
                <button id="hint-button">Hint</button>
            </div>
            <div id="game-area">
                <div id="card-grid"></div>
            </div>
        </div>
    </div>

    <div id="error-dialog" class="hidden">
        <div class="modal-content error-content">
            <p class="error-message"></p>
            <button class="error-close-btn">OK</button>
        </div>
    </div>

    <script src="app.js" type="module"></script>
    <script src="infinite.js" type="module"></script>
</body>
</html>



================================================
FILE: static/infinite.js
================================================
import * as game from './app.js';


document.addEventListener('DOMContentLoaded', () => {
    game.hintButton.addEventListener('click', () => game.getHint('infinite'));
    startGame();
});

function startGame() {
    console.log("Starting infinite game...");
    game.gameBoardDiv.classList.remove('hidden');
    game.setScore(0);
    if(game.scoreSpan) {
        game.scoreSpan.textContent = game.score;
    }
    game.setExcludedCardsQueue([]);
    game.setSeed(new URLSearchParams(window.location.search).get('seed') || null);
    game.dealInitialCards('infinite');
}



================================================
FILE: static/style.css
================================================
@import url('https://fonts.googleapis.com/css2?family=VT323&family=Press+Start+2P&display=swap');

body {
    font-family: 'VT323', monospace;
    display: flex;
    justify-content: center;
    align-items: center;
    min-height: 100vh;
    margin: 0;
    background-color: #d4d4d4;
    background-image: url("data:image/svg+xml,%3Csvg width='6' height='6' viewBox='0 0 6 6' xmlns='http://www.w3.org/2000/svg'%3E%3Cg fill='%239C92AC' fill-opacity='0.2' fill-rule='evenodd'%3E%3Cpath d='M5 0h1L0 6V5zM6 5v1H5z'/%3E%3C/g%3E%3C/svg%3E");
    font-size: 1.2em;
    color: #1a1a1a;
}

#game-container {
    text-align: center;
    padding: 30px;
    background: #e8e8e8;
    border: 3px solid #000;
    box-shadow: 8px 8px 0 #000;
    position: relative;
}

.hidden {
    display: none !important;
}

#game-controls {
    display: flex;
    justify-content: center;
    align-items: center;
    gap: 30px;
    margin-bottom: 25px;
    padding: 15px;
    background: #fff;
    border: 2px solid #000;
    box-shadow: inset 2px 2px 5px rgba(0,0,0,0.2);
}

#stats {
    display: flex;
    gap: 25px;
    font-family: 'Press Start 2P', cursive;
    font-size: 0.8em;
    color: #000;
}

#stats p {
    margin: 0;
    text-shadow: 2px 2px #e8e8e8;
}

button {
    font-family: 'Press Start 2P', cursive;
    padding: 12px 24px;
    font-size: 0.8em;
    border: 3px solid #000;
    background: linear-gradient(145deg, #fefefe, #e8e8e8);
    box-shadow: 5px 5px 0 #000;
    cursor: pointer;
    transition: all 0.1s ease;
    color: #000;
    text-transform: uppercase;
    position: relative;
}

button:hover {
    transform: translate(2px, 2px);
    box-shadow: 3px 3px 0 #000;
}

button:active {
    transform: translate(5px, 5px);
    box-shadow: none;
}

#hint-button {
    background: linear-gradient(145deg, #ffd700, #ffa500);
}

#game-area {
    display: flex;
    gap: 20px;
}

#card-grid {
    display: grid;
    grid-template-columns: repeat(4, 1fr);
    gap: 20px;
    padding: 20px;
    background: #fff;
    border: 2px solid #000;
    box-shadow: inset 3px 3px 6px rgba(0,0,0,0.2);
}

#challenge-sets-container {
    width: 250px;
    padding: 15px;
    background: #fff;
    border: 2px solid #000;
    box-shadow: inset 2px 2px 5px rgba(0,0,0,0.2);
}

#all-sets-list {
    display: flex;
    flex-direction: column;
    gap: 10px;
    max-height: 500px;
    overflow-y: auto;
}

.set-item {
    display: flex;
    gap: 5px;
    padding: 5px;
    border: 2px solid #ccc;
    background-color: #f0f0f0;
}

.set-item.found {
    background-color: #e0ffe0;
    border-color: #32cd32;
}

.set-item .card {
    width: 50px;
    height: 75px;
    padding: 2px;
    box-shadow: none;
    border-width: 2px;
}

.set-item .card svg {
    height: 20px !important;
}

.set-item .card.hidden-card {
    background: #ccc;
}

.card {
    width: 110px;
    height: 165px;
    padding: 10px;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    background: linear-gradient(145deg, #ffffff, #f0f0f0);
    border: 3px solid #000;
    box-shadow: 5px 5px 0 #000;
    cursor: pointer;
    transition: all 0.2s ease-in-out;
    position: relative;
}

.card:hover {
    transform: translateY(-5px);
    box-shadow: 7px 7px 0 #000;
}

.card svg {
    flex-shrink: 0;
    max-width: 98%;
    width: auto;
    filter: drop-shadow(2px 2px 0 rgba(0,0,0,0.3));
}

.card.count-1 svg { height: 60px; }
.card.count-2 svg { height: 50px; }
.card.count-3 svg { height: 42px; }

.card.selected {
    border-color: #4a90e2;
    background: linear-gradient(145deg, #4a90e2, #357abd);
    box-shadow: 5px 5px 0 #1a1a1a;
    transform: scale(1.05);
}

.card.hint {
    border-color: #ffd700;
    background: linear-gradient(145deg, #ffd700, #ffa500);
    box-shadow: 5px 5px 0 #1a1a1a;
}

#card-grid.five-columns {
    grid-template-columns: repeat(5, 1fr);
    grid-template-rows: repeat(3, 1fr);
}

#card-grid.three-columns {
    grid-template-columns: repeat(3, 1fr);
    grid-template-rows: repeat(5, 1fr);
}

@media (max-width: 800px) {
    #game-area {
        flex-direction: column;
    }

    #challenge-sets-container {
        width: auto;
        max-height: 200px;
    }

    #card-grid.five-columns {
        grid-template-columns: repeat(4, 1fr);
    }
    #game-container {
        padding: 20px;
        width: 95%;
    }

    #card-grid {
        grid-template-columns: repeat(4, 1fr);
        gap: 10px;
    }

    .card {
        width: auto;
        height: 100px;
    }
}

@media (max-width: 600px) {
    body {
        font-size: 1em;
        padding: 10px 0;
        align-items: flex-start;
    }

    #game-container {
        padding: 10px;
        border-width: 2px;
        box-shadow: none;
        width: 100%;
        box-sizing: border-box;
    }

    #game-controls {
        flex-direction: column;
        gap: 15px;
        padding: 10px;
        margin-bottom: 15px;
    }

    #stats {
        gap: 15px;
        font-size: 0.7em;
        flex-direction: column;
        align-items: center;
    }

    button {
        padding: 10px 20px;
        font-size: 0.7em;
        box-shadow: 3px 3px 0 #000;
    }

    button:hover {
        transform: translate(1px, 1px);
        box-shadow: 2px 2px 0 #000;
    }

    button:active {
        transform: translate(3px, 3px);
        box-shadow: none;
    }

    #card-grid {
        gap: 10px;
        padding: 10px;
    }

    #card-grid, #card-grid.five-columns {
        grid-template-columns: repeat(4, 1fr);
    }

    .card {
        height: auto;
        min-height: 100px;
        padding: 5px;
        box-shadow: 3px 3px 0 #000;
    }

    .card:hover {
        transform: translateY(-3px);
        box-shadow: 5px 5px 0 #000;
    }

    .card.count-1 svg { height: 40px; }
    .card.count-2 svg { height: 35px; }
    .card.count-3 svg { height: 30px; }

    .modal-content {
        padding: 20px;
        width: 90%;
        box-sizing: border-box;
    }

    h2, h3 {
        font-size: 1em;
        text-shadow: 2px 2px #e8e8e8;
    }

    #setup {
        padding: 15px;
    }

    input[type="text"], input[type="checkbox"], label {
        font-size: 1em;
    }
}

@media (max-width: 400px) {
    #card-grid, #card-grid.five-columns {
        grid-template-columns: repeat(3, 1fr);
    }
}


#error-dialog,
#game-over-modal {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0,0,0,0.7);
    display: flex;
    justify-content: center;
    align-items: center;
    backdrop-filter: blur(3px);
}

#game-over-modal {
    z-index: 100;
}

#error-dialog {
    z-index: 110;
}

.modal-content {
    background: #e8e8e8;
    padding: 30px;
    border: 3px solid #000;
    box-shadow: 8px 8px 0 #000;
    text-align: center;
    font-family: 'VT323', monospace;
    font-size: 1.2em;
}

#game-over-modal .modal-content {
    background-color: #d4d4d4;
    background-image: url("data:image/svg+xml,%3Csvg width='6' height='6' viewBox='0 0 6 6' xmlns='http://www.w3.org/2000/svg'%3E%3Cg fill='%239C92AC' fill-opacity='0.2' fill-rule='evenodd'%3E%3Cpath d='M5 0h1L0 6V5zM6 5v1H5z'/%3E%3C/g%3E%3C/svg%3E");
}

.error-content {
    min-width: 300px;
    border-left: 8px solid #dc3545;
}

.error-message {
    color: #dc3545;
    font-size: 1.2em;
    margin: 15px 0 25px;
    font-family: 'Press Start 2P', cursive;
    text-shadow: 2px 2px #000;
}

.error-close-btn {
    background: linear-gradient(145deg, #ffd700, #ffa500);
    color: white;
    text-shadow: 2px 2px #000;
}

#leaderboard-list {
    list-style-type: none;
    padding: 15px;
    background: #fff;
    border: 2px solid #000;
    box-shadow: inset 3px 3px 6px rgba(0,0,0,0.2);
    font-family: 'VT323', monospace;
    font-size: 1.2em;
    text-align: left;
    margin-top: 20px;
}

input[type="text"],
input[type="checkbox"] {
    font-family: 'VT323', monospace;
    padding: 10px;
    font-size: 1.2em;
    border: 3px solid #000;
    background: #fff;
    box-shadow: inset 2px 2px 5px rgba(0,0,0,0.2);
    margin: 10px 0;
}

input[type="checkbox"] {
    width: 20px;
    height: 20px;
    cursor: pointer;
}

label {
    font-family: 'VT323', monospace;
    font-size: 1.2em;
    margin-left: 8px;
}

#setup {
    display: flex;
    flex-direction: column;
    gap: 15px;
    align-items: center;
    padding: 20px;
    background: #fff;
    border: 2px solid #000;
    box-shadow: inset 3px 3px 6px rgba(0,0,0,0.2);
    margin-bottom: 20px;
}

.mode-selection {
    display: flex;
    gap: 20px;
    justify-content: center;
    align-items: center;
    flex-direction: column;
}

.start-button {
    background: linear-gradient(145deg, #32cd32, #228b22);
    color: white;
    text-shadow: 2px 2px #000;
    margin-top: 10px;
    min-width: 100%;
}

#back-button-container {
    position: absolute;
    top: 10px;
    left: 10px;
    z-index: 10;
}

h2, h3 {
    font-family: 'Press Start 2P', cursive;
    font-size: 1.2em;
    color: #000;
    text-shadow: 3px 3px #e8e8e8;
    margin: 20px 0;
}


================================================
FILE: static/timed.html
================================================
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Set - Timed Mode</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <div id="back-button-container">
        <button id="back-button"><-</button>
    </div>
    <div id="game-container">
        <div id="game-board" class="hidden">
            <div id="game-controls">
                <div id="stats">
                    <p>Time: <span id="timer">30</span>s</p>
                    <p>Score: <span id="score">0</span></p>
                </div>
                <button id="hint-button">Hint</button>
            </div>
            <div id="game-area">
                <div id="card-grid"></div>
            </div>
        </div>
    </div>

    <div id="error-dialog" class="hidden">
        <div class="modal-content error-content">
            <p class="error-message"></p>
            <button class="error-close-btn">OK</button>
        </div>
    </div>

    <div id="game-over-modal" class="hidden">
        <div class="modal-content">
            <h2>Game Over!</h2>
            <p>Your score: <span id="final-score">0</span></p>
            <input type="text" id="name-input" placeholder="Enter your name">
            <button id="submit-score-button">Submit Score</button>
            <h3>Leaderboard</h3>
            <ul id="leaderboard-list"></ul>
        </div>
    </div>

    <script src="app.js" type="module"></script>
    <script src="timed.js" type="module"></script>
</body>
</html>



================================================
FILE: static/timed.js
================================================
import * as game from './app.js';


document.addEventListener('DOMContentLoaded', () => {
    document.getElementById('submit-score-button').addEventListener('click', game.submitScore);
    game.hintButton.addEventListener('click', () => game.getHint('timed'));
    startGame();
});

function startGame() {
    console.log("Starting timed game...");
    game.gameBoardDiv.classList.remove('hidden');
    game.gameOverModal.classList.add('hidden');
    game.setScore(0);
    game.scoreSpan.textContent = game.score;
    game.setSeed(new URLSearchParams(window.location.search).get('seed') || null);
    game.setTimeLeft(30);
    game.timerSpan.textContent = game.timeLeft;
    game.setTimer(setInterval(updateTimer, 1000));
    game.dealInitialCards('timed');
}

function updateTimer() {
    game.removeTimeLeft(1);
    game.timerSpan.textContent = game.timeLeft;
    if (game.timeLeft <= 0) {
        console.log("Timer finished.");
        clearInterval(game.timer);
        game.endGame('timed');
    }
}


